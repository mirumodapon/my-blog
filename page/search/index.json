[{"content":"最近在公司與公司的夥伴協作的時候，往往有需要傳遞一些檔案的修改方式，其實大多數在改動的時候都是直接用版本管理工具像是 git 或是 svn（沒錯先不要懷疑，在 2025 的今天，我們公司還在使用 svn），但在有些情境下，我們可能不想推到 git server 上（比如說敏感資料檔案不會被 git 追蹤）。\nGNU diffutils 接下來要先介紹 GNU diffutils，這是 GNU 發布的比較工具包。在有些 Linux 發行版當中已經預設安裝了，如果在你的發行版中沒有這個工具包。你可以利用你的套件管理工具安裝 diffutils：\nubuntu:\n1 $ apt install diffutils cmp cmp - compare two files byte by byte\ncmp 會在發現第一個相異點之後停下來，並且回傳不一樣的地方資訊。 這個指令會透過位元組的方式比較兩個檔案，基本用法如下：\n1 2 3 cmp file1 file2 # output: # file1 file2 differ: byte 1, line 1 -b, --print-bytes 可以用來顯示不一樣的地方是什麼：\n1 2 3 cmp -b file1 file2 # output: # file1 file2 differ: byte 1, line 1 is 164 t 150 h -i, --ignore-initial=SKIP 跳過 n 個 bytes 在進行比較：\n1 2 # 從第 3 個 byte 開始比較 (跳過 2 個 bytes) cmp -i 2 file1 file2 也可以分別設定兩個檔案要跳過的 bytes 數量：\n1 2 3 # 第一個檔案從第 3 個 byte 開始比較 (跳過 2 個 bytes) # 第二個檔案從第 4 個 byte 開始比較 (跳過 3 個 bytes) cmp -i 2:3 file1 file2 這個指令大多用來比較兩個檔案是否完全相同。\ndiff diff - compare files line by line\n這個指令最主要是要比較文本，他會比對兩個文本是否一致並且把不一樣的地方列出來。 這邊我先準備兩個檔案來更好的解釋：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 cat \u0026lt;\u0026lt; EOF \u0026gt; file1.cpp #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0 } EOF cat \u0026lt;\u0026lt; EOF \u0026gt; file2.cpp #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } EOF 接著我們就可以用 diff 來比較差異了：\n1 2 3 4 5 6 7 8 9 10 diff file1.cpp file2.cpp # output: # 1a2 # \u0026gt; using namespace std; # 4,5c5,6 # \u0026lt; std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; # \u0026lt; return 0 # --- # \u0026gt; cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; # \u0026gt; return 0; 輸出說明 觀察輸出我們可以得到：\n1a2：\n前面的數字 1 表示 file1.cpp 的第一行 後面的數字 2 表示 file2.cpp 的第二行 a 表示新增了一行 4,5c5,6:\n前面的 4,5 表示 file1.cpp 的第四行到第五行\n後面的 5,6 表示 file2.cpp 的第五行到第六行\n表達完更改的地方之後，後面就是更改的內容啦！用 \u0026lt; 表示 file1.cpp 的檔案，\u0026gt; 則表示 file2.cpp 的檔案。\n這樣你可能會覺得很複雜因此我們可以加入 -u, -U NUM, --unified[=NUM] 來用 git 風格的格式顯示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 diff -u file1.cpp file2.cpp # output: # --- file1.cpp 2026-02-08 19:35:32.593297916 +0800 # +++ file2.cpp 2026-02-08 19:35:32.596297778 +0800 # @@ -1,6 +1,7 @@ # #include \u0026lt;iostream\u0026gt; # +using namespace std; # # int main() { # - std::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; std::endl; # - return 0 # + cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; # + return 0; # } 輸出說明 第一與第二行的 --- 與 +++ 分別表示 file1.cpp 與 file2.cpp。後面則為最後修改時間。 @@ -1,6 +1,7 @@ -1,6：舊檔從第 1 行開始，共 6 行 +1,7：新檔從第 1 行開始，共 7 行 sdiff sdiff - side-by-side merge of file differences\n這個指令也是用來顯示兩個檔案不一樣的地方，最大的不同是他會以左右並排的方式呈現，這應該是人類最好閱讀的方式。\n1 sdiff file1.cpp file2.cpp patch 這應該就是今天的重點了，我們利用完 diff 指令可以直接存成檔案：\n1 diff file1 file2 \u0026gt; file.patch 這樣就可以把生成出來的檔案直接丟給同事，接著他只要用下方的指令，就可以直接把改動的部分直接更新到他的電腦：\n1 patch file \u0026lt; file.path 這麼一來就不會有改錯檔案的問題啦！\n延伸閱讀 git apply diff3 參考資料 GNU Diffutils ","date":"2025-08-23T22:17:33+08:00","image":"https://blog.mirumo.net/post/diffandpatch/cover_hu_cfcc4626f32ffbc8.png","permalink":"https://blog.mirumo.net/post/diffandpatch/","title":"用 Diff 與 Patch 精準傳遞檔案修改"},{"content":"今天是整個旅程的最後一天了，明天起床直後就會直接到機場了，\n我跟女朋友起床之後，發現其他人還在賴床，因此我就跟女朋友先出門囉！ 旅程的最後一天，基本上就是要各種購物，帶東西回台灣的 XD\n築地市場 在開始購物之前，我們來到了築地市場，想買一些東西先填飽肚子。 聽說以前的築地市場非常的熱鬧，但現在好像沒落了不少。\n我們在市場逛了一下，買了一些小吃，就準備前往東京銀座 Shopping 了。\n東京銀座 接著就是買東西的時間啦！\n","date":"2025-06-16T20:59:23+09:00","image":"https://blog.mirumo.net/post/japan20250616/cover_hu_436c90e500564410.jpeg","permalink":"https://blog.mirumo.net/post/japan20250616/","title":"揪配逆斯 2025 - Shopping Day"},{"content":"昨天已經晚了一個多小時出門，想當然爾，一天比一天還要更晚。\n原本的行程規劃是先前往賀須神社，朝聖《你的名字》電影中的經典場景， 但今天比昨天又更晚出發，於是這個行程就直接取消了。\n今天的移動方向改為往原宿前進， 相較於前幾天，距離我們住宿的地方要再遠一些。\n明治神宮 今天的第一個行程來到了明治神宮。跟昨天都市的行程對比，節奏明顯的變慢了不少。 在這種腳逛到要斷的狀態下，放慢節奏\u0026hellip;\n只能說心靈上放鬆了不少，但沒地方坐，腳還是持續跟我抱怨著 QAQ\n幸運的是，我們在神社當中遇到有人正在舉行婚禮， 新郎新娘穿著傳統的神前婚禮服裝，在神職人員的引導下緩緩前行。\n竹下通 走出明治神宮之後，旁邊就是一條很熱鬧的接到，也就是「竹下通」。 裡面充滿了人潮，其實逛起來不是很舒服。在街道裡想買東西吃都會被排隊的人潮打退堂鼓。\n逛了一圈之後，我們在附近找了一間鰻魚飯專賣店。\n明治神宮外苑 雖然早上沒有去成賀須神社，朝聖電影的經典場景，但這個行程就是另一個場景了。 一群人到明治神宮外院旁的天橋拍了許久，還拿電影場景來對應著拍。\n我們放慢了角度，在明治神宮外院逛了一圈。最後在附近找到了椅子坐下來休息。\n就在這時，女朋友手機滑到一間小酒吧， 他看著照片中的甜點兩眼發光，於是我們起身前往這間小酒吧(https://maps.app.goo.gl/EFjXc35whmto43ne7)。\n到了小酒霸之後，現場沒有什麼位置可以讓我們 8 個人坐下來，稍等了大約十分鐘後， 店員很熱情的出來幫我們調整座位，讓我們可以坐下來，享受 Chill Chill 的下午。\n澀谷 Sky 接近傍晚，我們前往澀谷 SKY。 這就是標準的觀光景點了，在 IG 上一直滑到，現在終於有機會來到。 我們在上面待了兩個多小時，最後在附近的涉谷橫町找到了一間店，來結束這一天的旅程。\n","date":"2025-06-15T22:37:02+09:00","image":"https://blog.mirumo.net/post/japan20250615/cover_hu_3e3547b5da8b7fbc.jpeg","permalink":"https://blog.mirumo.net/post/japan20250615/","title":"揪配逆斯 2025 - 從神宮的安靜走到澀谷的天空"},{"content":"整端旅程都還沒一半，我就快走到腳快斷了 QAQ，每個人回到民宿都跟一團爛泥一樣。 原本今天約八點要出門，然後一堆人在賴床，一路就拖到了快九點半。 不過今天的行程好像也沒有那麼緊湊，就好像其實也不用約那麼早。\n今天是個肥宅行程，沒辦法我們這邊就是一群死宅砲，所以出發之後就直奔秋葉原！ 我們在約略十一點的時候秋葉原車店。這時候已經差不多接近中午了，我們就先找吃的。 其實在車上的時候，就已經開始 Google 找吃的，原本找了一間漢堡排的店，結果排的整個都是人。 沒辦法只好去旁邊的百貨公司覓食。完食之後，大家都說有點空虛，覺得吃起來沒有那個價值， 總之有吃飽就好了。\n秋葉原 吃完之後，我們就往秋葉原的方向走了。一整條路上都是動漫相關的店， 各種扭蛋、一番賞還有周邊，路邊偶而還會看到 Coser 在發宣傳單，看起來是什麼女僕咖啡廳的宣傳， 不過這群死宅砲顯然還沒有那個勇氣去踏進女僕咖啡廳。\n在秋葉原的街區當中，兩旁的人行道比起台灣的人行道大多了，大概有個 4 ~ 5 倍吧！ 但這麼大的人行道，卻還是擠滿了人。\n我的女友雖然不是宅宅，平常也是不怎麼看動漫的人，唯一有看的就是「海賊王」， 於是我跟她就達成了一個共識，就是至少要買一個海賊王的周邊。 最後她看到了一款拼圖，眼前一亮，這是由無數角色照片拼湊成的大圖， 最後她就下手了，提著戰利品笑得像個孩子，然後一直叫我回去要幫她拼。\n2025/08/24 更新 結果到現在只拼完了 10 % 而已\n2026/06/08 更新 終於全部拼完了！\n逛到最後，其他夥伴打了電話來，說他們找到了一間好玩的店，傳了座標就叫我們趕快過去。 這是一間大型的夾娃娃機店，一樓跟二樓是滿滿的機台，而三樓則是街機機台。 我們在三樓會合，看到他們的時候，他們居然跟路人在連線打魂鬥羅。 而手上已經是滿滿的東西了，看起來是已經在樓下打了一輪了。\n我跟女友就開始在這間店裡閑晃，後來看到一隻可愛的卡比，隨手 200 日圓就拿下， 在女友面前直接秀了一手，但我只能說「台灣人就是誇不得」，後續的魯夫公仔直接翻車， 最後還被其他人撿了尾刀。\n上野恩賜公園 - 五條天神社 接著，下一個行程是上野恩賜公園，我們在傍晚的時候抵達。 公園的規模比我想像中的大了不少，站在路口前的圖，開始有人因為腳酸而猶豫要不要進去。 不過來都來了，不進去拍張照片說不過去啊！ 最後只挑了一個比較近的景點\u0026mdash;五條天神社， 神社裡相對安靜，感覺是已經準備要關門了，也沒什麼遊客，\n我們就隨便逛了一圈後，發現只剩下神社大門是開著的，其他小門都已經關閉了。 原本想說沿著進來的方向出去就好，結果那個方向的門已經關了，最後又繞了大半圈才走出去。\n阿美橫町 最後，來到了阿美橫町。我發常喜歡日本這種商店街的氣份，與台灣夜市的風格不太一樣， 沒有台灣夜市那種推車攤販，而是兩排的商店，招牌也整起了許多， 總是覺得「別人的總是比較好」\n才逛進去沒多久，我們就看到一間挺大間的藥妝店，於是我們就又進去各種買東西， 我是沒有想到我們在這個藥妝店可以逛一個多小時，也沒有想到我們會在這裡買到這麼多的東西, 原本後天有排 Shopping 的行程，今天就把藥妝店要買的東西都買完了。\n後來大夥們找了一間燒烤店，這間店有點像是居酒屋的氣氛， 份量偏小，但味道不錯。只是有人在旁邊抽煙，實在是很擾人， 果然是到哪裡都有這種到處抽煙，不考慮別人的人 (怒！\n","date":"2025-06-14T23:13:20+09:00","image":"https://blog.mirumo.net/post/japan20250614/cover_hu_3ee6f319157892dd.jpeg","permalink":"https://blog.mirumo.net/post/japan20250614/","title":"揪配逆斯 2025 - 動漫迷與購物狂的東京行"},{"content":"原本以為今天要輕鬆一點，沒想到不知哪來的動力，大家居然不只準時， 甚至還提早集合，直接往淺草出發。 事後證明，早起真的是正確的選擇 —— 抵達時仲見世通上的人還不多， 陽光斜斜地灑在兩旁的老店鋪上，整條街都透著一種寧靜的美感。 這個時間來拍照，完美。\n我們先隨意逛了逛，邊走邊拍照，然後決定先去填飽肚子。 走到附近一家老派的咖啡店 ——「咖啡老舖 友路有 淺草店」。 店內布置滿滿的昭和風味，像是走進時光隧道。 我點了一份簡單的早餐套餐：熱奶茶、厚片吐司加上一顆煎蛋。 味道不複雜，但卻溫暖人心， 有種「真的醒在日本」的感覺——彷彿動畫裡咬著吐司衝出門的場景突然成真了。 雷門淺草寺 但就在我們悠閒吃著早餐的短短 30 分鐘裡，外頭的世界瞬間變了樣。 剛走進咖啡店時，外頭還是陽光斜灑、行人稀疏， 一副平日早晨的模樣，結果等我們一轉身準備離開， 整條仲見世通已經擠得水洩不通。觀光客像是突然從地下冒出來似的， 整條街瞬間被熱鬧與喧囂吞沒。原本還覺得自己像當地人一樣優雅漫步， 下一秒就被人潮推進了觀光模式，節奏直接切換。\n我們跟著隊伍般的觀光人流慢慢移動，邊走邊拍照，邊吃邊看，一路晃到了淺草寺主殿。 這些場景在無數的電影、動漫當中出現，現在終於身在其中，雖然在螢幕上看過無數次， 但當我親身走到它底下抬頭仰望時，心中還是無比的悸動。 那份熟悉卻又陌生的震撼，好像某個長久以來只存在於畫面裡的夢境，突然穿越次元落到了現實世界。 那一刻，旅程有了一種特別的重量， 帶著這份悸動，我們一路跟著人潮走進了主殿。香火裊裊，莊嚴的氣氛與外頭的熱鬧形成鮮明對比，讓人忍不住放慢腳步。 就在大家準備離開時，有人突然提議：「要不要來求個籤？」 眾人立刻點頭同意，興致勃勃地排隊抽籤。 我和女友各自搖動竹筒，心裡帶著點小小的期待。 打開籤盒的那一瞬間， 場面卻意外戲劇化——同行的四位朋友全都是「吉」，只有我們情侶檔雙雙「凶」。 接著笑聲四起，大家紛紛拿著自己的「吉籤」在我們面前比來比去，完全沒有要安慰的意思。 當下我和女友真的只有被嘲笑的份。\n墨田水族館 晴空塔的樓層裡有各種購物、美食，還有不少娛樂設施。 其中四樓特別設有一座小巧卻精緻的水族館。 因為前陣子大熱的動畫《莉可莉絲》曾在這裡取景， 我們也特地把這個地方列進行程。 雖然這個水族館不大，但卻是我非常喜歡的行程。 一走進昏暗的空間，耳邊只有輕柔的水聲和低沉音樂， 下一刻映入眼簾的，是一群微微發著鮮豔光的水母， 像漂浮在夜空中的小燈籠，優雅而夢幻。 不確定水母是自己發光，還是因為小燈的映照， 但整個畫面美得讓人屏息。 微微發亮的水母在昏暗的空間裡悠悠漂浮，彷彿置身於深黑的深海 ，眼前是那些奇妙、會發光的生物在水中舞動。 那種幽藍光影與寧靜感交織的氛圍，讓人完全忘記時間，只想靜靜看著它們優雅地遊動。 東京晴空塔 傍晚，我們搭乘高速電梯直上東京晴空塔的觀景台。 站在觀景台上俯瞰整個城市。 一次就能同時看到白天與夜晚的景色，城市的燈光逐漸亮起，河面倒映著點點燈火， 整個東京像被無數小星星點綴。微風輕拂，夜色與燈海交織， 白天的悠閒漫步與水族館的靜謐，在此刻都得到了完美的收束，令人既興奮又心滿意足。 在觀景台上方的天望回廊，正展出名偵探柯南特展。 迴廊兩側整排貼滿了角色海報，每個角色都栩栩如生。 站在這裡，不禁想到東京晴空塔在名偵探柯南中多次登場的場景：動畫裡的玻璃曾被開了數槍、千瘡百孔。 我和女友忍不住開始討論起柯哀和新蘭哪對CP更有魅力，她力挺新蘭的甜蜜互動，我則支持柯哀的默契與細膩情感。 在民宿的晚餐 晚餐，我們在附近的超市買了一些特價的即期食材，回到民宿自己動手開煮。 不得不說，同行好友的手藝實在不錯，香氣四溢，味道也十分驚喜。 我和女友幾乎沒有下過廚，看著他們熟練地操作食材， 忍不住感嘆：這樣的手藝，他們怎麼還沒找到另一半呢？ 邊吃邊笑鬧，這頓簡單的晚餐反而成了我們這天旅程中最溫馨、有趣的時刻之一。\n","date":"2025-06-13T22:51:39+09:00","image":"https://blog.mirumo.net/post/japan20250613/cover_hu_6966bfdd059ec15e.png","permalink":"https://blog.mirumo.net/post/japan20250613/","title":"揪配逆斯 2025 - 淺草晨光與晴空塔的夜景"},{"content":"從一月訂完機票到現在，終於迎來我可以出境的日子。 因為研發替代役的關係，在六月以前我無法離境，如今終於能踏上久違的海外旅程。\n我們一行六人從台灣出發，搭乘國泰航空 CX450 飛往東京。 飛機上有位空姐長相甜美，英文口音優雅動聽，讓人倍感親切與愉悅。 可惜她負責的區域不包括我的座位。 雖然國泰的飛機餐常被人詬病，但這次的宮保雞丁卻出乎意料地合我口味， 是個令人開心的小驚喜。\n抵達日本後，入境大排長龍， 花了不少時間才通關，稍嫌疲憊。 但就在這時，女友竟然巧遇了同校的朋友，在異國他鄉遇見熟人 ，這份巧合讓人驚喜不已，也讓我們對接下來的旅程充滿期待。\n剛下飛機時，人生地不熟，只能憑著手機導航與一點直覺摸索方向。 好不容易才找到通往 Airbnb 的火車路線，總算完成抵達東京的第一項任務。\n這次我們選擇搭乘 Sky Aces 的路線，經過青砥轉車，最後抵達了京成立石站。 步行回住宿的途中，經過一條充滿在地風情的商店街， 與常見的觀光景點風格大異其趣，街道氛圍樸實自然，別有一番風味。\n我們入住的民宿是一棟小巧溫馨的家庭式房屋，六個人共享一整層空間， 有客廳、餐桌與廚房，設備齊全。 大家一拍即合，決定找一天晚上一起下廚，好好「炸廚房」一次， 為這趟旅程增添趣味。\n稍作休息後，我們到附近覓食， 選中了一家文字燒餐廳(もん字屋)。 這種料理和中華料理很不一樣，需要自己動手在鐵板上慢慢煎熟。 店員看到我們是外國人，特地親切地前來示範製作方式， 讓我們能夠放心享用這道地美食。\n一邊煎著文字燒、一邊聊天，感覺彷彿置身於日本動畫或日劇的世界， 真實又夢幻。餐廳氣氛宛如溫馨的居酒屋，充滿在地的人情味。 雖然老闆的英文帶著濃厚的日本腔，我大多聽不太懂， 但幸好女友能理解並幫忙翻譯，整體氛圍十分歡樂。 文字燒的醬汁味道濃郁，讓我聯想到中式燴飯，熟悉中又帶著新鮮感。\n吃完晚餐後，我們沿著街道散步，細細感受日本建築的層次與晚間涼爽的空氣。 由於晚餐份量不多，我們還特地繞去便利商店買泡麵。 令人驚喜的是，日本泡麵的風味比想像中更有深度， 也許是異地旅遊的心情加成，讓味覺變得格外敏銳。\n就這樣，我們充滿驚喜與新鮮感的第一天，在笑聲與探索中劃下句點。 期待接下來的日子裡，會有更多難忘的回憶等待著我們去發現。\n","date":"2025-06-12T23:12:35+09:00","image":"https://blog.mirumo.net/post/japan20250612/cover_hu_4aa0c507a2403961.jpg","permalink":"https://blog.mirumo.net/post/japan20250612/","title":"揪配逆斯 2025 - 踏入日本"},{"content":"Rust 程式基本語法 首先我們來看看一段簡單的程式，這段程式會印出 Hello World！\n1 2 3 fn main() { println!(\u0026#34;Hello, World!\u0026#34;); } 其中：\nfn 是定義函數的關鍵字，main 是函數的名稱，也是整個程式的入口。 () 是函數的參數，這裡是空的。 {} 是函數的內容，這裡是程式的主體。 println! 印出字串到終端（帶有 ! 表示它是一個宏 macro）。 這就是 Rust 的基本架構。\nRust 的變數 變數的宣告 在 Rust 可以用 let 關鍵字來定義變數。\n1 let x = 5; 這裡的 x 是變數的名稱，5 是變數的初始值。\n這裡的數值預設為 i32，也就是 32 位元整數。\n我們也可以在變數宣告時指定變數的型態。\n1 let y: i64 = 5; 如此一來 y 的型態就是 i64，也就是 64 位元整數。\n接著，我們可以用 println! 來印出變數的值。\n1 2 3 4 fn main() { let z = 12; println!(\u0026#34;z = {}\u0026#34;, z); } println! 的第一個參數是字串， 字串中 \u0026quot;z = {}\u0026quot; 使用了 {}， 這是佔位符（placeholder），表示要插入一個變數的值， 這個值會在接續的參數中被指定。\n可變與不可變變數 在 Rust 中，變數的預設為不可變的（immutable）， 當我們試圖改變變數的值時，會得到錯誤。\n1 2 let x = 5; x = 12; // ❌ 如果我們想要改變變數的值時， 我們需要在變數宣告的時候，加上 mut 關鍵字。\n1 2 let y = 12; y = 5; // ⭕️ 數值的表示方式 我們可以用以下方法來表示數值：\n十進制數字： 12, -12 十六進制數字： 0x6D, -0x4F 八進制數字： 0o12, -0o12 二進制數字： 0b1101, -0b1101 浮點數： 12.5, -12.5, 12.5e2, -12.5e2 字元： 'a', '中', '😊' 字串： \u0026quot;Hello, World! 👋\u0026quot; 布林值： true, false 這些數值都是可以在 Rust 中使用的。\nRust 中的資料型態 基本資料型態 在 Rust 中，基本資料型態包括:\n整數（integer） 型別 描述 i8 有符號 8 位元整數 i16 有符號 16 位元整數 i32 有符號 32 位元整數 i64 有符號 64 位元整數 i128 有符號 128 位元整數 isize 有符號系統依據的位元數 u8 無符號 8 位元整數 u16 無符號 16 位元整數 u32 無符號 32 位元整數 u64 無符號 64 位元整數 u128 無符號 128 位元整數 usize 無符號系統依據的位元數 浮點數（float） 型別 描述 f32 32 位元浮點數 f64 64 位元浮點數 布林（boolean） 在 Rust 中，布林值以 bool 這個型別來表示，其值為 true 或 false。\n字元（character） 在 Rust 中，字元是一個 4 位元的 Unicode 字元。並且以 char 這個型別來表示字元。\n複合資料型態 元組（tuple） 元組是一組相同或不相同型別的值的集合。\n使用 小括號 ( ) 包住，並用逗號 , 分隔元素。\nTuple 的長度是固定的，定義後無法改變。\n1 let tuple: (i8, char, f32) = (1, \u0026#39;2\u0026#39;, 3.0); 並且我們可以用解構賦值來讀取元組中的值。\n1 let (x, y, z) = tuple; 如果想要讀取元組中的某一個值時，可以使用 .。\n1 2 let x = tuple.0 // 第一個元素 let y = tuple.1 // 第二個元素 陣列（array） 陣列是固定長度的資料集合，其中每個元素都有相同的型別。\n陣列的大小在宣告時就必須確定，無法動態擴展。\n1 2 3 fn main() { let numbers = [1, 2, 3, 4, 5]; } 我們也可以用 [type; length] 來宣告陣列：\n1 2 3 4 fn main() { let numbers: [i32; 5] = [12; 5] // [12; 5] 等同於 [12, 12, 12, 12, 12] } 在使用陣列時，與大部分的程式語言一樣，使用 arr[index] 來讀取陣列中的元素。\n1 2 3 4 5 6 7 8 fn main() { let numbers = [12, 34, 56, 78, 90]; let first = numbers[0]; let last = numbers[4]; println!(\u0026#34;The first number is {}\u0026#34;, numbers[0]); println!(\u0026#34;The last number is {}\u0026#34;, numbers[4]); } 註解 在 Rust 中，可以使用 // 或是 /* */ 來註解程式碼。\n1 2 3 4 5 // 這是一個單行註解 /* * 這是一個多行註解 */ Rust 中的控制流程 if 條件判斷 Rust 當中的 if 與大部分的程式語言的使用方式是類似的，\n當然也跟其他程式語言一樣，可以使用 else if 來增加條件判斷。\n比較嚴格的是條件判斷必須是 bool 型別。\n1 2 3 4 5 6 7 8 9 fn main() { let age = 18; if age \u0026gt;= 18 { println!(\u0026#34;You are an adult!\u0026#34;); } else { println!(\u0026#34;You are a child!\u0026#34;); } } 而在 Rust 當中，並沒有三元運算子，但我們可以使用 if 來達成相同的效果。\n值得注意的是，在 if 與 else 最後的內容不需要加上分號，而且必須是相同的型別。\n1 2 3 4 5 fn main() { let age = 18; let message = if age \u0026gt;= 18 { \u0026#34;You are an adult!\u0026#34; } else { \u0026#34;You are a child!\u0026#34; }; println!(\u0026#34;{}\u0026#34;, message); } 並且我們也可以在 {} 當中，使用多個表達式。\n1 2 3 4 5 6 7 8 9 fn main() { let x = 5; let y = if x \u0026gt; 0 { let z = 3; z * 2 } else { -1 }; println!(\u0026#34;The value of y is {}\u0026#34;, y); // 6 } match 條件判斷 match 類似於其程式語言中的 switch，用來對整數、字串、字元等值進行比對。\n1 2 3 4 5 6 7 8 fn main() { let x = 1; match x { 0 =\u0026gt; println!(\u0026#34;Hello\u0026#34;), 1 =\u0026gt; println!(\u0026#34;World\u0026#34;), _ =\u0026gt; println!(\u0026#34;!\u0026#34;), } } 在這段程式中，我們使用 match 來判斷 x 的值，並依照不同的值來執行不同的操作。\n其中 _ 代表其他不符合上述條件的值。\nmatch 也跟 if 一樣，回傳符合條件的數值。\n1 2 3 4 5 6 7 8 9 fn main() { let x = \u0026#39;A\u0026#39;; let y = match x { \u0026#39;A\u0026#39; =\u0026gt; 1, \u0026#39;B\u0026#39; =\u0026gt; 2, } println!(\u0026#34;{}\u0026#34;, y); // 1 } 另外，match 可以多個條件合併，又或是在整數區間當中。\n1 2 3 4 5 6 7 8 fn main() { let x = 3; let y = match x { 1 | 2 =\u0026gt; -1, 4..=6 =\u0026gt; 3, // 4 \u0026lt;= x \u0026lt;= 6 7..8 =\u0026gt; 4, // 7 \u0026lt;= x \u0026lt; 8 }; } loop 迴圈 loop 是在 Rust 當中的無限循環迴圈，通常使用 break 或是配合 return 來跳出迴圈。\n1 2 3 4 5 6 7 8 9 10 11 fn main() { let mut x = 0; loop { println!(\u0026#34;Hello, World!\u0026#34;); x += 1; if x \u0026gt; 10 { break; } } } while 迴圈 while 與大部分程式語言行為相同，在符合條件下，持續執行迴圈內的程式。\n1 2 3 4 5 6 7 fn main() { let mut x = 0; while x \u0026lt; 5 { println!(\u0026#34;Hello, World!\u0026#34;); x += 1; } } for 迴圈 在 Rust 中，for 迴圈主要針對數組和迭代器進行迴圈運算。\n1 2 3 4 5 6 fn main() { let arr = [1, 2, 3]; for x in arr { println!(\u0026#34;{}\u0026#34;, x); } } 要注意的是 tuple 是不能使用 for 迴圈的。\n我們可以搭配 .iter() 與 .enumerate() 來使用迭代器。\n1 2 3 4 5 6 fn main() { let arr = [1, 2, 3]; for (index, x) in arr.iter().enumerate() { println!(\u0026#34;{}: {}\u0026#34;, index, x); } } 如果要使用在字串當中，可以使用 .chars()。\n1 2 3 4 5 6 fn main() { let s = \u0026#34;Hello, World!\u0026#34;; for c in s.chars() { println!(\u0026#34;{}\u0026#34;, c); } } 也可以在 for 迴圈中，使用連續整數\n1 2 3 4 5 6 7 8 9 fn main() { for x in 0..10 { println!(\u0026#34;{}\u0026#34;, x); } for x in (0..=10).rev() { } } 其中，.rev() 可以將其反轉。\nbreak 與 continue 迴圈控制 beark 可以用來跳出迴圈，continue 可以用來繼續下一次迴圈。\n首先我們來看 break\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn main() { let mut x = 0; let mut sum = 0; loop { x += 1; if x % 2 == 0 { continue; } if x \u0026gt; 10 { break; } } } 我們也可以幫迴圈標籤，並且在迴圈中指定要 break 或 continue 的迴圈。\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { let mut x = 0; \u0026#39;outer: loop { x += 1; loop { x += 1; if x % 10 == 0 { continue \u0026#39;outer; } } } } 最後，我們來介紹 break 的回傳功能。\n1 2 3 4 5 6 7 8 9 fn main() { let mut x = 0; let y = loop { x += 1; if x \u0026gt; 10 { break x } } } 我們可以利用 break 來回傳數值，這裡跟 match 或是 if 一樣，回傳的數值後面不用加分號。\n函式（Function） 在基本架構中，我們提到了程式的入口 main，就是一個函式，\n我們使用 fn 來定義函式。\n1 2 3 fn say_hello() { println!(\u0026#34;Hello, World!\u0026#34;); } 函式的參數、回傳值、呼叫函式等等，跟大部分程式語言的概念是一樣的，\n這裡就不再進一步介紹了。\n比較值得注意的是我們可以在參數後方加上 -\u0026gt; 來指定回傳值的型別。\n1 2 3 fn add(x: i32, y: i32) -\u0026gt; i32 { return x + y; } 並且在函式當中的最後一個陳述式，在不加上分號的情況下，會自動作為回傳值被回傳。\n1 2 3 4 5 6 7 fn add(x: i32, y: i32) -\u0026gt; i32 { x + y } fn main() { println!(\u0026#34;{}\u0026#34;, add(1, 2)); // 3 } 陳述式與表達式 Rust 是基於表達式的語言（expression-based），因此在這個小節，我們要介紹的是陳述式和表達式的差別。\n陳述式（Statements） 陳述式代表著程式當中的指令，這個指令不會回傳任何的數值。 像是：\n1 let x = 12; 表達式（Expressions） 而表達式則是指程式當中的計算結果，這個計算結果會回傳一個數值。\n我們來看看這個範例：\n1 2 3 4 5 6 7 8 fn main() { let x = { let a = 12; a \u0026lt;\u0026lt; 1 } println!(\u0026#34;{}\u0026#34;, x); // 24 } 這個範例中的 {}，如同函式的回傳一樣，就是表達式的一部分。\n而其實在前幾個小節當中，我們已經看到了表達式，像是：\n1 2 3 match x { ... } 還有 if 條件判斷的表達式，這些可以產生一個數值的指令，也是表達式的一種。\n參考資料 Rust Official Documentation Book, Section 3 ","date":"2025-04-22T22:42:36+08:00","image":"https://blog.mirumo.net/post/rustlearnwithai2/cover_hu_56281bf031c25feb.png","permalink":"https://blog.mirumo.net/post/rustlearnwithai2/","title":"用 AI 加速學習：Rust 基本語法與資料型態"},{"content":"Rust 是什麼？ Rust 是一個邊一行的程式語言，主打安全性、速度、並行處理。 相對於其他程式語言來說 Rust 可以說是非常年輕的， 2012 年 1 月懷上的它，直到 2015 年 5 月 15 日才出生。\n安裝 Rust 在 Rust 個官方網站中， 推薦了使用 rustup 來安裝 Rust。 rustup 是 Rust 官方提供的工具鏈安裝與管理器， 可以讓你方便地安裝 Rust、切換不同版本。 Unix-like 作業系統可以執行以下指令來安裝 rustup：\n1 $ curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 接這我們就可以使用 rustup 指令來安裝 Rust。\n1 $ rustup install stable 這個指令會幫我們下載 Rust 的穩定版本，與相關的工具（包含 rustfmt、cargo 等）。\nHello Rust 安裝完之後，可以使用 rustc --version 指令來檢查是否安裝成功。 這是 Rust 的編譯器，可以用來編譯 Rust 程式。\n接這我們就可以開始寫 Rust 程式了！ 首先建立一個檔案 hello.rs，並在裡面寫入以下程式：\n1 2 3 fn main() { println!(\u0026#34;Hello, Rust!\u0026#34;); } 其中：\nfn 是建立函數的關鍵字。 main 是函數的名稱，在 Rust 當中 main 作為整個程式的入口。 println! 以 ! 結尾在 Rust 中表示巨集（macro）。 \u0026quot;Hello, Rust!\u0026quot; 是要印出的字串。 接著使用以下指令來編譯程式：\n1 $ rustc hello.rs 這樣就可以編譯出一個與檔案名稱相同的執行檔了。 我們試著執行這個執行檔。\n1 2 $ ./hello Hello, Rust! Cargo Cargo 是 Rust 的建置工具與套件管理工具， 大多數專案都會透過 Cargo 進行管理。\n透過 rustup 安裝 Rust 時，Cargo 也會一併安裝。\n首現我們先用 Cargo 建立一個專案：\n1 $ cargo new hello_cargo 這時 cargo 會幫我們建立一個結構如下的資料夾：\n1 2 3 4 5 6 7 hello_cargo ├── .git │ └── (...) ├── src │ └── main.rs ├── Cargo.toml └── .gitignore 其中，main.rs 是程式的入口，Cargo.toml 是專案的配置檔。\n進入專案資料夾後，我們可以打開 src/main.rs，並且將剛剛的程式寫入這個檔案中。 接著透過 Cargo 指令來執行專案。Cargo 會自動編譯原始碼並執行可執行檔。\n1 2 3 4 5 $ cargo run Compiling hello_rust v0.1.0 (/playground/hello_rust) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.17s Running `target/debug/hello_rust` Hello, world! 這個指令執行直，會先編譯 src/main.rs，再執行程式。 這個編譯的結果，會生成在路徑 target/debug/hello_rust 當中。\n我們也可以編譯但不執行檔案：\n1 $ cargo build 或是僅檢查程式的語法錯誤，但不編譯該程式：\n1 $ cargo check 最後，當我們完成了專案時，可以使用 release 模式進行最佳化編譯。\n1 $ cargo build --release 這會產生效能更好的執行檔，放在 target/release 目錄中。雖然編譯時間會增加，但執行效率會大幅提升。\n參考資料 Rust Official Documentation Book, Section 1 Rust in 100 Seconds ","date":"2025-03-29T22:58:27+08:00","image":"https://blog.mirumo.net/post/rustlearnwithai1/cover_hu_34f0f62f06c1171a.png","permalink":"https://blog.mirumo.net/post/rustlearnwithai1/","title":"用 AI 加速學習：Rust 語言簡介與環境設置"},{"content":"大家都說 Rust 很難，上手的難度簡直高得讓人望而卻步。\n語法跟概念堆得跟魔王塔一樣高，還暗藏陷阱，一個不注意就直接卡關回城重練。\n我一開始滿腔熱血地衝進去，結果三秒鐘後腦袋就冒煙。🤯\n。。。\n所以我召喚來了 Ai 來進攻 Rust 編譯器。\n「請幫我規劃一個完整的 rust 學習地圖，分為多個小節，並且以條列的方式點出該小節的重要概念。提供我可以一步一步的學習 rust 語言的規劃，並且在每個小節都設計練習題，讓我更加熟練 rust。」\nRust 語言簡介與環境設置 重要概念： Rust 語言特色與優點（安全性、速度、並發） 安裝 Rust：使用 Rustup 工具 Cargo：Rust 的建構與套件管理工具 練習題： 安裝 Rust 與 Cargo，並確認安裝是否成功。 使用 Cargo 建立你的第一個專案，編寫並執行 \u0026ldquo;Hello, world!\u0026rdquo; 範例。 基本語法與資料型態 重要概念： 變數與不可變性（預設不可變，使用 mut 開啟可變性） 基本資料型態：整數、浮點數、布林、字串、陣列、元組 函數定義與呼叫 條件判斷（if/else）與迴圈（loop、while、for） 練習題： 撰寫一個簡單的計算機程式，利用條件判斷選擇不同運算。 使用迴圈印出 1 至 10 的數字，嘗試用不同迴圈結構實作。 所有權、借用與生命週期 重要概念： 所有權系統：每個值都有且僅有一個所有者 借用：不可變借用與可變借用，理解借用規則 生命週期：如何告知編譯器資料有效範圍 練習題： 撰寫函數傳遞字串與數值，觀察所有權的轉移與借用。 嘗試修改程式碼，故意引發借用錯誤，並依照編譯器提示進行修正。 結構、列舉與模式匹配 重要概念： 結構體（Structs）：定義與使用自訂資料型態。 列舉（Enums）：定義有限狀態或選項集合。 模式匹配（match）：根據模式做分支處理。 Option 與 Result：處理可能缺失或錯誤的值。 練習題： 定義一個描述幾何圖形（例如圓形、矩形）的列舉，並使用 match 輸出相應的面積計算。 實作一個簡單的錯誤處理範例，使用 Option 或 Result 處理可能的錯誤狀況。 泛型、Traits 與實作 重要概念： 泛型：使函數或結構體能處理不同型態資料。 Trait：定義共通行為，並實作於不同型態。 標準 trait（如 Debug、Clone、PartialEq）與自定義 trait。 練習題： 寫一個泛型資料結構（例如 Stack 或 Queue），並為其實作 Debug trait。 定義一個自訂 trait 並實作於至少兩個不同型態，嘗試在程式中使用多態性。 模組系統與包管理 重要概念： 模組（mod）：如何組織程式碼與資料夾結構。 Crate：Rust 的編譯單位。 Cargo.toml：管理專案依賴與設定。 練習題： 建立一個包含多個模組的小專案，嘗試在不同模組間共享函數與變數。 在 Cargo.toml 中加入第三方 crate（例如 serde），並寫一個小範例使用該庫進行資料序列化。 錯誤處理與 panic 重要概念： Result 型態：成功與錯誤狀況的處理方式。 Option 型態：處理可能缺失的值。 錯誤傳播（使用 ? 運算子）與 panic 機制。 練習題： 撰寫一個檔案 I/O 範例，利用 Result 處理讀取檔案過程中的錯誤。 改寫函數，從使用 unwrap 改為正確的錯誤傳播與處理。 併發程式設計 重要概念： 線程（threads）：如何建立與管理線程。 併發安全：Send 與 Sync 特質。 Mutex 與 Channel：保護共享資源與線程間通訊。 練習題： 撰寫一個多線程程式，使用 Mutex 保護共用計數器。 使用 Channel 實作生產者-消費者模型。 智能指標與內存管理 重要概念： Box：在堆上分配記憶體。 Rc 與 Arc：多重所有權與跨線程安全共享。 RefCell 與 Cell：在編譯時期無法確定所有權時提供內部可變性。 練習題： 撰寫一個簡單的樹狀結構，利用 Rc 與 RefCell 管理節點間的參考。 嘗試使用 Arc 在多線程中共享不可變資料。 宏與程式自動化 重要概念： 宏（macro_rules!）：編譯時期程式碼生成與重用。 Attribute 宏：透過屬性標記自動生成程式碼。 程式碼縮減與重構。 練習題： 撰寫一個簡單的宏，生成重複性程式碼（例如簡化多個相似函數的定義）。 使用宏改善現有程式碼的可讀性與重用性。 測試與除錯 重要概念： 單元測試（Unit Test）：模組內測試撰寫與執行。 整合測試（Integration Test）：跨模組與專案測試。 除錯技巧：使用 println!、logging 與除錯工具。 練習題： 為各個模組撰寫單元測試，確保邏輯正確。 撰寫整合測試，模擬使用者行為驗證專案整體運作。 Rust 生態系統與進階主題 重要概念： crates.io：如何搜尋並使用第三方庫。 WebAssembly 與嵌入式應用：Rust 的應用範疇擴展。 非同步程式設計（async/await）：處理非同步 I/O 與高效併發。 外部函式介面（FFI）：與 C/C++ 等語言整合。 練習題： 搜尋並整合一個第三方庫，撰寫一個簡單專案（如 Web API 或 CLI 工具）。 編寫一個使用 async/await 的非同步網路請求範例。 ","date":"2025-03-29T22:58:27+08:00","image":"https://blog.mirumo.net/post/rustlearnwithai0/cover_hu_513d4342abf9214f.png","permalink":"https://blog.mirumo.net/post/rustlearnwithai0/","title":"用 AI 加速學習：規劃 Rust 學習路徑"},{"content":"（GPT 取的標題 🤪）\n最近在逛 Apple 官網的時候，看到了 2 萬多塊 的 MacBook Air M2 整修品， 剛好我也快要受不了女朋友的電腦了，索性就下單了 ~~\n不過她是第一次用 Mac，於是我就先來幫她設定啦， 順便分享一下我常使用的 Mac 工具。\n終端機 iTerm2 身為一個軟體工程師（她應該之後也會是吧？！），終端機是我們很重要的工具。 iTerm2 是一個終端機模擬器（Terminal emulator），可以當作是macOS 上的強化版終端機， 提供比內建終端更強大的功能、客製化選項與提升生產力的特性，很適合開發者、系統管理員及資深使用者使用。\ntmux tmux（Terminal Multiplexer）是一款終端多工管理工具， 允許你在單一終端會話（Session）中管理多個視窗與面板， 並支援背景運行、遠端連線保持、分割視窗等功能。\n整合開發環境（IDE) Neovim Neovim 是 Vim 的改進版，目標是現代化、可擴充、提升效能， 並提供更友善的插件開發與 Lua 配置。 相較於傳統 Vim，Neovim 在 外掛系統、LSP（Language Server Protocol）、內建終端、多執行緒處理等方面有更好的支援， 使其成為現代開發者的首選終端編輯器。\n雖然這東西對初學的人來說很不友善，但她在 VSCode 裡也都用 Vim 模式，應該也沒什麼問題（吧？！）\nCursor Cursor 是由 VSCode Fork 出來的 IDE，它提供了生成式 AI 來幫助開發者寫程式。 只要打上需求，就自動寫出你要的功能，上班按按 Tab 就可以下班了 XD\nZed Zed 是一款由 Rust 開發的 IDE，比起 VSCode 速度可是快了非常的多。 它的一大亮點是它的即時協作功能，使得團隊中的多位開發者可以同時在同一個代碼庫中進行編輯。 同時也整合了 LLM 提供開發的協助。\nMarkdown 編輯器 這個部分最主要是作為筆記用的工具，而我對筆記工具沒什麼要求，支援 Markdown 輸出就行。\nZettlr 作為開源的推廣者，Zettlr 是我非常喜歡的一款開源 Markdown 編輯器， 畫面乾淨、簡單又容易上手。並且內建對 LaTeX、HTML 等格式的良好支援， 使其成為學術寫作、技術寫作、程式碼文檔等領域的理想選擇。\nObsidian Obsidian 是一款強大的知識管理和筆記整理工具， 可以使用 Markdown 格式進行筆記創建，並允許用戶將各個筆記通過雙向鏈接進行連接， 這使得它非常適合進行思維導圖、知識圖譜或者個人知識庫的管理。\n瀏覽器 Arc Arc 是一款由 The Browser Company 開發的創新型瀏覽器， 旨在提供一個更加現代化且以生產力為導向的瀏覽器體驗。 Arc 打破了傳統瀏覽器的界限，設計上注重簡潔、直觀的用戶界面，並致力於提升使用者的工作流程效率。\nZen Browser Zen Browser 的設計與 Arc 非常相似， 與 Arc 最大的不同是，Zen Browser 基於 Mozilla Firefox。\n命令行工具 bat bat 是一個 cat 替代品，用於在命令行中顯示文件內容。 它提供了語法辨識、行號顯示、分頁功能等，比傳統的 cat 更加直觀。\nfzf fzf 是一個模糊搜尋工具， 可以在終端機中，以選單的方式搜尋檔案、指令紀錄、運行的程式\u0026hellip;等。\n也有非常多的工具可以與 fzf 結合，讓搜尋變得更加靈活。\nripgrep ripgrep 是一款超快速的檔案內容搜尋工具， 用來取代傳統的 grep。 它比 grep、ack、ag（The Silver Searcher）更快，並且內建遞迴搜尋、忽略 .gitignore 規則。\ndelta delta 是一款美觀的 Git Diff Viewer，用來取代 git diff。 提供語法辨識、側邊欄、行內變更顯示，讓 git diff 變得更清晰易讀。\n","date":"2025-02-23T13:22:01+08:00","image":"https://blog.mirumo.net/post/commandlinetoolshare/cover_hu_c1f176ef62bbd935.png","permalink":"https://blog.mirumo.net/post/commandlinetoolshare/","title":"用對 Mac 工具，連貓都能寫程式"},{"content":"前陣子，我的女朋友帶著一臉焦急來找我求救，說她需要完成一個關於螞蟻演算法的報告，但完全不知道怎麼做，希望我幫幫他。「作業要自己做！」看了一下我的行程然後跟她說了這句話。\n。\n。\n。\n「好啦！」\n（專案 PR 我還沒 Review 完耶 QAQ ~）\n。\n。\n。\n❗️❗️ 女朋友表示：以上純屬虛構 ❗️❗️\n什麼是螞蟻演算法？ 螞蟻演算法（Ant Colony Optimization, ACO）是一種受自然界啟發的優化演算法， 其靈感來源於螞蟻群體尋找食物時的集體行為。 這個演算法由義大利科學家 Marco Dorigo 在 1992 年提出， 並在後續的研究中被廣泛應用於解決各種複雜的組合優化問題。\n螞蟻在探索食物時，會在經過的路徑上釋放費洛蒙， 費洛蒙的濃度越高，其他螞蟻選擇這條路徑的機率也越大。 然而，費洛蒙會隨時間揮發，因此如果一條路徑較長或效率較低， 費洛蒙的吸引力會逐漸減弱。 相反的，短而有效的路徑會因為更多螞蟻的選擇而累積更多費洛蒙，最終成為群體的最優選擇。螞蟻演算法的核心在於模擬這一過程，通過不斷迭代來逼近最優解。\n螞蟻演算法的步驟 螞蟻演算法通過以下幾個步驟來模擬螞蟻的行為：\n初始化：設定蟻群的活動空間，這個空間通常用來代表問題的解決範圍或解空間。同時，也會設定費洛蒙的初始濃度和其他參數。\n解的構建：蟻群中的螞蟻開始在活動空間中隨機遊走，根據費洛蒙濃度和啟發式資訊選擇路徑。\n費洛蒙更新：每當一隻螞蟻完成了一次解的建構，演算法便會更新這段路徑上的費洛蒙值。有效的路徑會獲得更多的費洛蒙，反之則會減少。\n迭代：重複步驟2和3，直到達到停止條件，如固定的迭代次數或解的改進程度不再顯著。\n通過這些步驟，螞蟻演算法能夠在解空間中發現隱藏的最佳解，並適應各種複雜的問題。\n1 2 3 4 5 6 7 procedure ACO_MetaHeuristic is while not terminated do generateSolutions() daemonActions() pheromoneUpdate() repeat end procedure 螞蟻的路徑選擇 螞蟻在選擇路徑時，主要依賴於費洛蒙的濃度。 具體來說，當濃度越高時，螞蟻選擇該路徑的機率也越高， 我們用以下公式來表示螞蟻從當前節點 \\(i\\) 選擇下一個節點 \\(j\\) 的機率：\n$$ P_{ij} = \\frac{\\tau_{ij}^{\\alpha} \\eta_{ij}^{\\beta}}{\\sum_{k \\in N_i} \\tau_{ik}^{\\alpha} \\eta_{ik}^{\\beta}} $$其中：\n\\(\\tau_{ij}\\) 代表從節點 \\(i\\) 到節點 \\(j\\) 的費洛蒙濃度。 \\(\\eta_{ij}\\) 代表啟發式資訊（該問題的結果優劣），通常是距離的倒數 \\(\\frac{1}{d_{ij}}\\)。 \\(\\alpha\\) 和 \\(\\beta\\) 是兩個參數，分別控制費洛蒙與啟發式資訊的影響程度。 \\(N_i\\) 為當前螞蟻可選擇的鄰近節點集合。 當 \\(\\alpha\\) 值較大時，螞蟻更傾向於選擇費洛蒙濃度高的路徑， 而當 \\(\\beta\\) 值較大時，則更強調啟發式資訊（如較短的距離）。 適當調整這些參數，能夠提升演算法的性能。\n費洛蒙的更新 費洛蒙更新機制確保了有效路徑的增強與次優路徑的淘汰。更新過程通常包含兩個部分：\n費洛蒙蒸發：為了避免過早收斂至局部最優解，費洛蒙會隨時間逐漸減少，其衰減公式為：\n$$ \\tau_{ij} \\leftarrow (1 - \\rho) \\cdot \\tau_{ij} $$其中，\\(\\rho\\) 為蒸發率（0 \u0026lt; \\(\\rho\\) \u0026lt; 1），用來控制費洛蒙的衰減速度。\n費洛蒙增強：當螞蟻成功找到解後，根據路徑長度分配新的費洛蒙：\n$$ \\tau_{ij} \\leftarrow \\tau_{ij} + \\sum_{k=1}^{m} \\Delta \\tau_{ij}^{k} $$其中，\\(\\Delta \\tau_{ij}^{k}\\) 為第 \\(k\\) 隻螞蟻在路徑上的費洛蒙貢獻， 通常與解的品質相關，例如：\\(\\Delta \\tau_{ij}^{k} = \\frac{Q}{L_k}\\)。\n\\(Q\\) 為常數，用來調整費洛蒙的強度。 \\(L_k\\) 為第 隻螞蟻找到的解的路徑長度，越短的路徑獲得的費洛蒙越多。 實作範例 最後，為了展示螞蟻演算法的應用，這裡以旅行推銷員問題（TSP）為例。 TSP 的目標是尋找最短路徑，使旅行推銷員能夠走訪所有城市且最終返回起點。\n參考資料 wikipedia - Ant colony optimization algorithms ","date":"2025-01-05T23:29:49+08:00","image":"https://blog.mirumo.net/post/antcolonyoptimization/cover_hu_f313963bd4fa7ba.png","permalink":"https://blog.mirumo.net/post/antcolonyoptimization/","title":"螞蟻演算法 - Python 範例"},{"content":"在資訊科技領域中，「Hello World」經常被用來作為測試開發環境是否正確設置的一種方式，透過將這段文字打印或顯示出來，開發者能迅速確認系統的基本運行狀態。因此我利用這篇文章，作為整個部落格的第一篇文。\nHello World 的起源 「Hello World」這個程式的歷史可以追溯到 1970 年代。《The C Programming Language》（C 語言程式設計）這本經典書籍中，Brian Kernighan 和 Dennis Ritchie 使用了一個簡單的範例來介紹如何在螢幕上顯示文字，而這個範例就是「Hello, World!」。由於其簡單易懂且不容易出錯，它很快成為程式設計入門的標誌。\n「Hello, World」的概念可以追溯到 Brian Kernighan 在 1974 年的內部技術手冊 《Programming in C: A Tutorial》， 他在該手冊中用 B 語言（C 語言的前身）展示了類似的範例程式碼：\n1 2 3 main() { printf(\u0026#34;hello, world\u0026#34;); } Hugo 功能測試 一般標記 斜體 *斜體*\n粗體 **粗體**\n刪除線 ~~刪除線~~\n標記 ==標記==\n底線 ++底線++\n上標 上^標^\n下標 下~標~\n程式碼 一般顯示 1 #define hugo 程式碼標記 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 for i := 0; i \u0026lt; 3; i++ { 7 fmt.Println(\u0026#34;Value of i:\u0026#34;, i) 8 } 9} Latex Math \\[ \\begin{aligned} KL(\\hat{y} || y) \u0026= \\sum_{c=1}^{M}\\hat{y}_c \\log{\\frac{\\hat{y}_c}{y_c}} \\\\ JS(\\hat{y} || y) \u0026= \\frac{1}{2}(KL(y||\\frac{y+\\hat{y}}{2}) + KL(\\hat{y}||\\frac{y+\\hat{y}}{2})) \\end{aligned} \\]This is an inline \\(a^*=x-b^*\\) equation.\nNote\nWarning\nSuccess\ntest 參考資料 wikipedia - \u0026ldquo;Hello, World!\u0026rdquo; program ","date":"2025-01-04T22:59:50+08:00","permalink":"https://blog.mirumo.net/post/helloworld/","title":"Hello World"}]