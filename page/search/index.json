[{"content":"（GPT 取的標題 🤪）\n最近在逛 Apple 官網的時候，看到了 2 萬多塊 的 MacBook Air M2 整修品， 剛好我也快要受不了女朋友的電腦了，索性就下單了 ~~\n不過她是第一次用 Mac，於是我就先來幫她設定啦， 順便分享一下我常使用的 Mac 工具。\n終端機 iTerm2 身為一個軟體工程師（她應該之後也會是吧？！），終端機是我們很重要的工具。 iTerm2 是一個終端機模擬器（Terminal emulator），可以當作是macOS 上的強化版終端機， 提供比內建終端更強大的功能、客製化選項與提升生產力的特性，很適合開發者、系統管理員及資深使用者使用。\ntmux tmux（Terminal Multiplexer）是一款終端多工管理工具， 允許你在單一終端會話（Session）中管理多個視窗與面板， 並支援背景運行、遠端連線保持、分割視窗等功能。\n整合開發環境（IDE) Neovim Neovim 是 Vim 的改進版，目標是現代化、可擴充、提升效能， 並提供更友善的插件開發與 Lua 配置。 相較於傳統 Vim，Neovim 在 外掛系統、LSP（Language Server Protocol）、內建終端、多執行緒處理等方面有更好的支援， 使其成為現代開發者的首選終端編輯器。\n雖然這東西對初學的人來說很不友善，但她在 VSCode 裡也都用 Vim 模式，應該也沒什麼問題（吧？！）\nCursor Cursor 是由 VSCode Fork 出來的 IDE，它提供了生成式 AI 來幫助開發者寫程式。 只要打上需求，就自動寫出你要的功能，上班按按 Tab 就可以下班了 XD\nZed Zed 是一款由 Rust 開發的 IDE，比起 VSCode 速度可是快了非常的多。 它的一大亮點是它的即時協作功能，使得團隊中的多位開發者可以同時在同一個代碼庫中進行編輯。 同時也整合了 LLM 提供開發的協助。\nMarkdown 編輯器 這個部分最主要是作為筆記用的工具，而我對筆記工具沒什麼要求，支援 Markdown 輸出就行。\nZettlr 作為開源的推廣者，Zettlr 是我非常喜歡的一款開源 Markdown 編輯器， 畫面乾淨、簡單又容易上手。並且內建對 LaTeX、HTML 等格式的良好支援， 使其成為學術寫作、技術寫作、程式碼文檔等領域的理想選擇。\nObsidian Obsidian 是一款強大的知識管理和筆記整理工具， 可以使用 Markdown 格式進行筆記創建，並允許用戶將各個筆記通過雙向鏈接進行連接， 這使得它非常適合進行思維導圖、知識圖譜或者個人知識庫的管理。\n瀏覽器 Arc Arc 是一款由 The Browser Company 開發的創新型瀏覽器， 旨在提供一個更加現代化且以生產力為導向的瀏覽器體驗。 Arc 打破了傳統瀏覽器的界限，設計上注重簡潔、直觀的用戶界面，並致力於提升使用者的工作流程效率。\nZen Browser Zen Browser 的設計與 Arc 非常相似， 與 Arc 最大的不同是，Zen Browser 基於 Mozilla Firefox。\n命令行工具 bat bat 是一個 cat 替代品，用於在命令行中顯示文件內容。 它提供了語法辨識、行號顯示、分頁功能等，比傳統的 cat 更加直觀。\nfzf fzf 是一個模糊搜尋工具， 可以在終端機中，以選單的方式搜尋檔案、指令紀錄、運行的程式\u0026hellip;等。\n也有非常多的工具可以與 fzf 結合，讓搜尋變得更加靈活。\nripgrep ripgrep 是一款超快速的檔案內容搜尋工具， 用來取代傳統的 grep。 它比 grep、ack、ag（The Silver Searcher）更快，並且內建遞迴搜尋、忽略 .gitignore 規則。\ndelta delta 是一款美觀的 Git Diff Viewer，用來取代 git diff。 提供語法辨識、側邊欄、行內變更顯示，讓 git diff 變得更清晰易讀。\n","date":"2025-02-23T13:22:01+08:00","image":"https://blog.mirumo.net/post/commandlinetoolshare/cover_hu12827853875206883214.png","permalink":"https://blog.mirumo.net/post/commandlinetoolshare/","title":"用對 Mac 工具，連貓都能寫程式"},{"content":"前陣子，我的女朋友帶著一臉焦急來找我求救，說她需要完成一個關於螞蟻演算法的報告，但完全不知道怎麼做，希望我幫幫他。「作業要自己做！」看了一下我的行程然後跟她說了這句話。\n。\n。\n。\n「好啦！」\n（專案 PR 我還沒 Review 完耶 QAQ ~）\n。\n。\n。\n❗️❗️ 女朋友表示：以上純屬虛構 ❗️❗️\n什麼是螞蟻演算法？ 螞蟻演算法（Ant Colony Optimization, ACO）是一種受自然界啟發的優化演算法， 其靈感來源於螞蟻群體尋找食物時的集體行為。 這個演算法由義大利科學家 Marco Dorigo 在 1992 年提出， 並在後續的研究中被廣泛應用於解決各種複雜的組合優化問題。\n螞蟻在探索食物時，會在經過的路徑上釋放費洛蒙， 費洛蒙的濃度越高，其他螞蟻選擇這條路徑的機率也越大。 然而，費洛蒙會隨時間揮發，因此如果一條路徑較長或效率較低， 費洛蒙的吸引力會逐漸減弱。 相反的，短而有效的路徑會因為更多螞蟻的選擇而累積更多費洛蒙，最終成為群體的最優選擇。螞蟻演算法的核心在於模擬這一過程，通過不斷迭代來逼近最優解。\n螞蟻演算法的步驟 螞蟻演算法通過以下幾個步驟來模擬螞蟻的行為：\n初始化：設定蟻群的活動空間，這個空間通常用來代表問題的解決範圍或解空間。同時，也會設定費洛蒙的初始濃度和其他參數。\n解的構建：蟻群中的螞蟻開始在活動空間中隨機遊走，根據費洛蒙濃度和啟發式資訊選擇路徑。\n費洛蒙更新：每當一隻螞蟻完成了一次解的建構，演算法便會更新這段路徑上的費洛蒙值。有效的路徑會獲得更多的費洛蒙，反之則會減少。\n迭代：重複步驟2和3，直到達到停止條件，如固定的迭代次數或解的改進程度不再顯著。\n通過這些步驟，螞蟻演算法能夠在解空間中發現隱藏的最佳解，並適應各種複雜的問題。\n1 2 3 4 5 6 7 procedure ACO_MetaHeuristic is while not terminated do generateSolutions() daemonActions() pheromoneUpdate() repeat end procedure 螞蟻的路徑選擇 螞蟻在選擇路徑時，主要依賴於費洛蒙的濃度。 具體來說，當濃度越高時，螞蟻選擇該路徑的機率也越高， 我們用以下公式來表示螞蟻從當前節點 \\(i\\) 選擇下一個節點 \\(j\\) 的機率：\n$$ P_{ij} = \\frac{\\tau_{ij}^{\\alpha} \\eta_{ij}^{\\beta}}{\\sum_{k \\in N_i} \\tau_{ik}^{\\alpha} \\eta_{ik}^{\\beta}} $$其中：\n\\(\\tau_{ij}\\) 代表從節點 \\(i\\) 到節點 \\(j\\) 的費洛蒙濃度。 \\(\\eta_{ij}\\) 代表啟發式資訊（該問題的結果優劣），通常是距離的倒數 \\(\\frac{1}{d_{ij}}\\)。 \\(\\alpha\\) 和 \\(\\beta\\) 是兩個參數，分別控制費洛蒙與啟發式資訊的影響程度。 \\(N_i\\) 為當前螞蟻可選擇的鄰近節點集合。 當 \\(\\alpha\\) 值較大時，螞蟻更傾向於選擇費洛蒙濃度高的路徑， 而當 \\(\\beta\\) 值較大時，則更強調啟發式資訊（如較短的距離）。 適當調整這些參數，能夠提升演算法的性能。\n費洛蒙的更新 費洛蒙更新機制確保了有效路徑的增強與次優路徑的淘汰。更新過程通常包含兩個部分：\n費洛蒙蒸發：為了避免過早收斂至局部最優解，費洛蒙會隨時間逐漸減少，其衰減公式為：\n$$ \\tau_{ij} \\leftarrow (1 - \\rho) \\cdot \\tau_{ij} $$其中，\\(\\rho\\) 為蒸發率（0 \u0026lt; \\(\\rho\\) \u0026lt; 1），用來控制費洛蒙的衰減速度。\n費洛蒙增強：當螞蟻成功找到解後，根據路徑長度分配新的費洛蒙：\n$$ \\tau_{ij} \\leftarrow \\tau_{ij} + \\sum_{k=1}^{m} \\Delta \\tau_{ij}^{k} $$其中，\\(\\Delta \\tau_{ij}^{k}\\) 為第 \\(k\\) 隻螞蟻在路徑上的費洛蒙貢獻， 通常與解的品質相關，例如：\\(\\Delta \\tau_{ij}^{k} = \\frac{Q}{L_k}\\)。\n\\(Q\\) 為常數，用來調整費洛蒙的強度。 \\(L_k\\) 為第 隻螞蟻找到的解的路徑長度，越短的路徑獲得的費洛蒙越多。 實作範例 最後，為了展示螞蟻演算法的應用，這裡以旅行推銷員問題（TSP）為例。 TSP 的目標是尋找最短路徑，使旅行推銷員能夠走訪所有城市且最終返回起點。\n參考資料 wikipedia - Ant colony optimization algorithms 圖片來源 封面圖片：GPT 生成 ","date":"2025-01-05T23:29:49+08:00","image":"https://blog.mirumo.net/post/antcolonyoptimization/cover_hu3700163009851773748.webp","permalink":"https://blog.mirumo.net/post/antcolonyoptimization/","title":"螞蟻演算法 - Python 範例"},{"content":"在資訊科技領域中，「Hello World」經常被用來作為測試開發環境是否正確設置的一種方式，透過將這段文字打印或顯示出來，開發者能迅速確認系統的基本運行狀態。因此我利用這篇文章，作為整個部落格的第一篇文。\nHello World 的起源 「Hello World」這個程式的歷史可以追溯到 1970 年代。《The C Programming Language》（C 語言程式設計）這本經典書籍中，Brian Kernighan 和 Dennis Ritchie 使用了一個簡單的範例來介紹如何在螢幕上顯示文字，而這個範例就是「Hello, World!」。由於其簡單易懂且不容易出錯，它很快成為程式設計入門的標誌。\n「Hello, World」的概念可以追溯到 Brian Kernighan 在 1974 年的內部技術手冊 《Programming in C: A Tutorial》， 他在該手冊中用 B 語言（C 語言的前身）展示了類似的範例程式碼：\n1 2 3 main() { printf(\u0026#34;hello, world\u0026#34;); } Hugo 功能測試 一般標記 斜體 *斜體*\n粗體 **粗體**\n刪除線 ~~刪除線~~\n標記 ==標記==\n底線 ++底線++\n上標 上^標^\n下標 下~標~\n程式碼 一般顯示 1 #define hugo 程式碼標記 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 for i := 0; i \u0026lt; 3; i++ { 7 fmt.Println(\u0026#34;Value of i:\u0026#34;, i) 8 } 9} Latex Math \\[ \\begin{aligned} KL(\\hat{y} || y) \u0026= \\sum_{c=1}^{M}\\hat{y}_c \\log{\\frac{\\hat{y}_c}{y_c}} \\\\ JS(\\hat{y} || y) \u0026= \\frac{1}{2}(KL(y||\\frac{y+\\hat{y}}{2}) + KL(\\hat{y}||\\frac{y+\\hat{y}}{2})) \\end{aligned} \\]This is an inline \\(a^*=x-b^*\\) equation.\n參考資料 wikipedia - \u0026ldquo;Hello, World!\u0026rdquo; program ","date":"2025-01-04T22:59:50+08:00","permalink":"https://blog.mirumo.net/post/helloworld/","title":"Hello World"}]