[{"content":"原本以為今天要輕鬆一點，沒想到不知哪來的動力，大家居然不只準時， 甚至還提早集合，直接往淺草出發。 事後證明，早起真的是正確的選擇 —— 抵達時仲見世通上的人還不多， 陽光斜斜地灑在兩旁的老店鋪上，整條街都透著一種寧靜的美感。 這個時間來拍照，完美。\n我們先隨意逛了逛，邊走邊拍照，然後決定先去填飽肚子。 走到附近一家老派的咖啡店 ——「咖啡老舖 友路有 淺草店」。 店內布置滿滿的昭和風味，像是走進時光隧道。 我點了一份簡單的早餐套餐：熱奶茶、厚片吐司加上一顆煎蛋。 味道不複雜，但卻溫暖人心， 有種「真的醒在日本」的感覺——彷彿動畫裡咬著吐司衝出門的場景突然成真了。 雷門淺草寺 但就在我們悠閒吃著早餐的短短 30 分鐘裡，外頭的世界瞬間變了樣。 剛走進咖啡店時，外頭還是陽光斜灑、行人稀疏， 一副平日早晨的模樣，結果等我們一轉身準備離開， 整條仲見世通已經擠得水洩不通。觀光客像是突然從地下冒出來似的， 整條街瞬間被熱鬧與喧囂吞沒。原本還覺得自己像當地人一樣優雅漫步， 下一秒就被人潮推進了觀光模式，節奏直接切換。\n我們跟著隊伍般的觀光人流慢慢移動，邊走邊拍照，邊吃邊看，一路晃到了淺草寺主殿。 這些場景在無數的電影、動漫當中出現，現在終於身在其中，雖然在螢幕上看過無數次， 但當我親身走到它底下抬頭仰望時，心中還是無比的悸動。 那份熟悉卻又陌生的震撼，好像某個長久以來只存在於畫面裡的夢境，突然穿越次元落到了現實世界。 那一刻，旅程有了一種特別的重量， 帶著這份悸動，我們一路跟著人潮走進了主殿。香火裊裊，莊嚴的氣氛與外頭的熱鬧形成鮮明對比，讓人忍不住放慢腳步。 就在大家準備離開時，有人突然提議：「要不要來求個籤？」 眾人立刻點頭同意，興致勃勃地排隊抽籤。 我和女友各自搖動竹筒，心裡帶著點小小的期待。 打開籤盒的那一瞬間， 場面卻意外戲劇化——同行的四位朋友全都是「吉」，只有我們情侶檔雙雙「凶」。 接著笑聲四起，大家紛紛拿著自己的「吉籤」在我們面前比來比去，完全沒有要安慰的意思。 當下我和女友真的只有被嘲笑的份。\n墨田水族館 晴空塔的樓層裡有各種購物、美食，還有不少娛樂設施。 其中四樓特別設有一座小巧卻精緻的水族館。 因為前陣子大熱的動畫《莉可莉絲》曾在這裡取景， 我們也特地把這個地方列進行程。 雖然這個水族館不大，但卻是我非常喜歡的行程。 一走進昏暗的空間，耳邊只有輕柔的水聲和低沉音樂， 下一刻映入眼簾的，是一群微微發著鮮豔光的水母， 像漂浮在夜空中的小燈籠，優雅而夢幻。 不確定水母是自己發光，還是因為小燈的映照， 但整個畫面美得讓人屏息。 微微發亮的水母在昏暗的空間裡悠悠漂浮，彷彿置身於深黑的深海 ，眼前是那些奇妙、會發光的生物在水中舞動。 那種幽藍光影與寧靜感交織的氛圍，讓人完全忘記時間，只想靜靜看著它們優雅地遊動。 東京晴空塔 傍晚，我們搭乘高速電梯直上東京晴空塔的觀景台。 站在觀景台上俯瞰整個城市。 一次就能同時看到白天與夜晚的景色，城市的燈光逐漸亮起，河面倒映著點點燈火， 整個東京像被無數小星星點綴。微風輕拂，夜色與燈海交織， 白天的悠閒漫步與水族館的靜謐，在此刻都得到了完美的收束，令人既興奮又心滿意足。 在觀景台上方的天望回廊，正展出名偵探柯南特展。 迴廊兩側整排貼滿了角色海報，每個角色都栩栩如生。 站在這裡，不禁想到東京晴空塔在名偵探柯南中多次登場的場景：動畫裡的玻璃曾被開了數槍、千瘡百孔 我和女友忍不住開始討論起柯哀和新蘭哪對CP更有魅力，她力挺新蘭的甜蜜互動，我則支持柯哀的默契與細膩情感。 在民宿的晚餐 晚餐，我們在附近的超市買了一些特價的即期食材，回到民宿自己動手開煮。 不得不說，同行好友的手藝實在不錯，香氣四溢，味道也十分驚喜。 我和女友幾乎沒有下過廚，看著他們熟練地操作食材， 忍不住感嘆：這樣的手藝，他們怎麼還沒找到另一半呢？ 邊吃邊笑鬧，這頓簡單的晚餐反而成了我們這天旅程中最溫馨、有趣的時刻之一。\n","date":"2025-06-13T22:51:39+09:00","image":"https://blog.mirumo.net/post/japan20250613/cover_hu10618267072870375324.png","permalink":"https://blog.mirumo.net/post/japan20250613/","title":"揪配逆斯 2025 - 淺草晨光與晴空塔的夜景"},{"content":"從一月訂完機票到現在，終於迎來我可以出境的日子。 因為研發替代役的關係，在六月以前我無法離境，如今終於能踏上久違的海外旅程。\n我們一行六人從台灣出發，搭乘國泰航空 CX450 飛往東京。 飛機上有位空姐長相甜美，英文口音優雅動聽，讓人倍感親切與愉悅。 可惜她負責的區域不包括我的座位。 雖然國泰的飛機餐常被人詬病，但這次的宮保雞丁卻出乎意料地合我口味， 是個令人開心的小驚喜。\n抵達日本後，入境大排長龍， 花了不少時間才通關，稍嫌疲憊。 但就在這時，女友竟然巧遇了同校的朋友，在異國他鄉遇見熟人 ，這份巧合讓人驚喜不已，也讓我們對接下來的旅程充滿期待。\n剛下飛機時，人生地不熟，只能憑著手機導航與一點直覺摸索方向。 好不容易才找到通往 Airbnb 的火車路線，總算完成抵達東京的第一項任務。\n這次我們選擇搭乘 Sky Aces 的路線，經過青砥轉車，最後抵達了京成立石站。 步行回住宿的途中，經過一條充滿在地風情的商店街， 與常見的觀光景點風格大異其趣，街道氛圍樸實自然，別有一番風味。\n我們入住的民宿是一棟小巧溫馨的家庭式房屋，六個人共享一整層空間， 有客廳、餐桌與廚房，設備齊全。 大家一拍即合，決定找一天晚上一起下廚，好好「炸廚房」一次， 為這趟旅程增添趣味。\n稍作休息後，我們到附近覓食， 選中了一家文字燒餐廳(もん字屋)。 這種料理和中華料理很不一樣，需要自己動手在鐵板上慢慢煎熟。 店員看到我們是外國人，特地親切地前來示範製作方式， 讓我們能夠放心享用這道地美食。\n一邊煎著文字燒、一邊聊天，感覺彷彿置身於日本動畫或日劇的世界， 真實又夢幻。餐廳氣氛宛如溫馨的居酒屋，充滿在地的人情味。 雖然老闆的英文帶著濃厚的日本腔，我大多聽不太懂， 但幸好女友能理解並幫忙翻譯，整體氛圍十分歡樂。 文字燒的醬汁味道濃郁，讓我聯想到中式燴飯，熟悉中又帶著新鮮感。 吃完晚餐後，我們沿著街道散步，細細感受日本建築的層次與晚間涼爽的空氣。 由於晚餐份量不多，我們還特地繞去便利商店買泡麵。 令人驚喜的是，日本泡麵的風味比想像中更有深度， 也許是異地旅遊的心情加成，讓味覺變得格外敏銳。\n就這樣，我們充滿驚喜與新鮮感的第一天，在笑聲與探索中劃下句點。 期待接下來的日子裡，會有更多難忘的回憶等待著我們去發現。\n","date":"2025-06-12T23:12:35+09:00","image":"https://blog.mirumo.net/post/japan20250612/cover_hu698575290148113900.jpg","permalink":"https://blog.mirumo.net/post/japan20250612/","title":"揪配逆斯 2025 - 踏入日本"},{"content":"Rust 程式基本語法 首先我們來看看一段簡單的程式，這段程式會印出 Hello World！\n1 2 3 fn main() { println!(\u0026#34;Hello, World!\u0026#34;); } 其中：\nfn 是定義函數的關鍵字，main 是函數的名稱，也是整個程式的入口。 () 是函數的參數，這裡是空的。 {} 是函數的內容，這裡是程式的主體。 println! 印出字串到終端（帶有 ! 表示它是一個宏 macro）。 這就是 Rust 的基本架構。\nRust 的變數 變數的宣告 在 Rust 可以用 let 關鍵字來定義變數。\n1 let x = 5; 這裡的 x 是變數的名稱，5 是變數的初始值。\n這裡的數值預設為 i32，也就是 32 位元整數。\n我們也可以在變數宣告時指定變數的型態。\n1 let y: i64 = 5; 如此一來 y 的型態就是 i64，也就是 64 位元整數。\n接著，我們可以用 println! 來印出變數的值。\n1 2 3 4 fn main() { let z = 12; println!(\u0026#34;z = {}\u0026#34;, z); } println! 的第一個參數是字串， 字串中 \u0026quot;z = {}\u0026quot; 使用了 {}， 這是佔位符（placeholder），表示要插入一個變數的值， 這個值會在接續的參數中被指定。\n可變與不可變變數 在 Rust 中，變數的預設為不可變的（immutable）， 當我們試圖改變變數的值時，會得到錯誤。\n1 2 let x = 5; x = 12; // ❌ 如果我們想要改變變數的值時， 我們需要在變數宣告的時候，加上 mut 關鍵字。\n1 2 let y = 12; y = 5; // ⭕️ 數值的表示方式 我們可以用以下方法來表示數值：\n十進制數字： 12, -12 十六進制數字： 0x6D, -0x4F 八進制數字： 0o12, -0o12 二進制數字： 0b1101, -0b1101 浮點數： 12.5, -12.5, 12.5e2, -12.5e2 字元： 'a', '中', '😊' 字串： \u0026quot;Hello, World! 👋\u0026quot; 布林值： true, false 這些數值都是可以在 Rust 中使用的。\nRust 中的資料型態 基本資料型態 在 Rust 中，基本資料型態包括:\n整數（integer） 型別 描述 i8 有符號 8 位元整數 i16 有符號 16 位元整數 i32 有符號 32 位元整數 i64 有符號 64 位元整數 i128 有符號 128 位元整數 isize 有符號系統依據的位元數 u8 無符號 8 位元整數 u16 無符號 16 位元整數 u32 無符號 32 位元整數 u64 無符號 64 位元整數 u128 無符號 128 位元整數 usize 無符號系統依據的位元數 浮點數（float） 型別 描述 f32 32 位元浮點數 f64 64 位元浮點數 布林（boolean） 在 Rust 中，布林值以 bool 這個型別來表示，其值為 true 或 false。\n字元（character） 在 Rust 中，字元是一個 4 位元的 Unicode 字元。並且以 char 這個型別來表示字元。\n複合資料型態 元組（tuple） 元組是一組相同或不相同型別的值的集合。\n使用 小括號 ( ) 包住，並用逗號 , 分隔元素。\nTuple 的長度是固定的，定義後無法改變。\n1 let tuple: (i8, char, f32) = (1, \u0026#39;2\u0026#39;, 3.0); 並且我們可以用解構賦值來讀取元組中的值。\n1 let (x, y, z) = tuple; 如果想要讀取元組中的某一個值時，可以使用 .。\n1 2 let x = tuple.0 // 第一個元素 let y = tuple.1 // 第二個元素 陣列（array） 陣列是固定長度的資料集合，其中每個元素都有相同的型別。\n陣列的大小在宣告時就必須確定，無法動態擴展。\n1 2 3 fn main() { let numbers = [1, 2, 3, 4, 5]; } 我們也可以用 [type; length] 來宣告陣列：\n1 2 3 4 fn main() { let numbers: [i32; 5] = [12; 5] // [12; 5] 等同於 [12, 12, 12, 12, 12] } 在使用陣列時，與大部分的程式語言一樣，使用 arr[index] 來讀取陣列中的元素。\n1 2 3 4 5 6 7 8 fn main() { let numbers = [12, 34, 56, 78, 90]; let first = numbers[0]; let last = numbers[4]; println!(\u0026#34;The first number is {}\u0026#34;, numbers[0]); println!(\u0026#34;The last number is {}\u0026#34;, numbers[4]); } 註解 在 Rust 中，可以使用 // 或是 /* */ 來註解程式碼。\n1 2 3 4 5 // 這是一個單行註解 /* * 這是一個多行註解 */ Rust 中的控制流程 if 條件判斷 Rust 當中的 if 與大部分的程式語言的使用方式是類似的，\n當然也跟其他程式語言一樣，可以使用 else if 來增加條件判斷。\n比較嚴格的是條件判斷必須是 bool 型別。\n1 2 3 4 5 6 7 8 9 fn main() { let age = 18; if age \u0026gt;= 18 { println!(\u0026#34;You are an adult!\u0026#34;); } else { println!(\u0026#34;You are a child!\u0026#34;); } } 而在 Rust 當中，並沒有三元運算子，但我們可以使用 if 來達成相同的效果。\n值得注意的是，在 if 與 else 最後的內容不需要加上分號，而且必須是相同的型別。\n1 2 3 4 5 fn main() { let age = 18; let message = if age \u0026gt;= 18 { \u0026#34;You are an adult!\u0026#34; } else { \u0026#34;You are a child!\u0026#34; }; println!(\u0026#34;{}\u0026#34;, message); } 並且我們也可以在 {} 當中，使用多個表達式。\n1 2 3 4 5 6 7 8 9 fn main() { let x = 5; let y = if x \u0026gt; 0 { let z = 3; z * 2 } else { -1 }; println!(\u0026#34;The value of y is {}\u0026#34;, y); // 6 } match 條件判斷 match 類似於其程式語言中的 switch，用來對整數、字串、字元等值進行比對。\n1 2 3 4 5 6 7 8 fn main() { let x = 1; match x { 0 =\u0026gt; println!(\u0026#34;Hello\u0026#34;), 1 =\u0026gt; println!(\u0026#34;World\u0026#34;), _ =\u0026gt; println!(\u0026#34;!\u0026#34;), } } 在這段程式中，我們使用 match 來判斷 x 的值，並依照不同的值來執行不同的操作。\n其中 _ 代表其他不符合上述條件的值。\nmatch 也跟 if 一樣，回傳符合條件的數值。\n1 2 3 4 5 6 7 8 9 fn main() { let x = \u0026#39;A\u0026#39;; let y = match x { \u0026#39;A\u0026#39; =\u0026gt; 1, \u0026#39;B\u0026#39; =\u0026gt; 2, } println!(\u0026#34;{}\u0026#34;, y); // 1 } 另外，match 可以多個條件合併，又或是在整數區間當中。\n1 2 3 4 5 6 7 8 fn main() { let x = 3; let y = match x { 1 | 2 =\u0026gt; -1, 4..=6 =\u0026gt; 3, // 4 \u0026lt;= x \u0026lt;= 6 7..8 =\u0026gt; 4, // 7 \u0026lt;= x \u0026lt; 8 }; } loop 迴圈 loop 是在 Rust 當中的無限循環迴圈，通常使用 break 或是配合 return 來跳出迴圈。\n1 2 3 4 5 6 7 8 9 10 11 fn main() { let mut x = 0; loop { println!(\u0026#34;Hello, World!\u0026#34;); x += 1; if x \u0026gt; 10 { break; } } } while 迴圈 while 與大部分程式語言行為相同，在符合條件下，持續執行迴圈內的程式。\n1 2 3 4 5 6 7 fn main() { let mut x = 0; while x \u0026lt; 5 { println!(\u0026#34;Hello, World!\u0026#34;); x += 1; } } for 迴圈 在 Rust 中，for 迴圈主要針對數組和迭代器進行迴圈運算。\n1 2 3 4 5 6 fn main() { let arr = [1, 2, 3]; for x in arr { println!(\u0026#34;{}\u0026#34;, x); } } 要注意的是 tuple 是不能使用 for 迴圈的。\n我們可以搭配 .iter() 與 .enumerate() 來使用迭代器。\n1 2 3 4 5 6 fn main() { let arr = [1, 2, 3]; for (index, x) in arr.iter().enumerate() { println!(\u0026#34;{}: {}\u0026#34;, index, x); } } 如果要使用在字串當中，可以使用 .chars()。\n1 2 3 4 5 6 fn main() { let s = \u0026#34;Hello, World!\u0026#34;; for c in s.chars() { println!(\u0026#34;{}\u0026#34;, c); } } 也可以在 for 迴圈中，使用連續整數\n1 2 3 4 5 6 7 8 9 fn main() { for x in 0..10 { println!(\u0026#34;{}\u0026#34;, x); } for x in (0..=10).rev() { } } 其中，.rev() 可以將其反轉。\nbreak 與 continue 迴圈控制 beark 可以用來跳出迴圈，continue 可以用來繼續下一次迴圈。\n首先我們來看 break\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn main() { let mut x = 0; let mut sum = 0; loop { x += 1; if x % 2 == 0 { continue; } if x \u0026gt; 10 { break; } } } 我們也可以幫迴圈標籤，並且在迴圈中指定要 break 或 continue 的迴圈。\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { let mut x = 0; \u0026#39;outer: loop { x += 1; loop { x += 1; if x % 10 == 0 { continue \u0026#39;outer; } } } } 最後，我們來介紹 break 的回傳功能。\n1 2 3 4 5 6 7 8 9 fn main() { let mut x = 0; let y = loop { x += 1; if x \u0026gt; 10 { break x } } } 我們可以利用 break 來回傳數值，這裡跟 match 或是 if 一樣，回傳的數值後面不用加分號。\n函式（Function） 在基本架構中，我們提到了程式的入口 main，就是一個函式，\n我們使用 fn 來定義函式。\n1 2 3 fn say_hello() { println!(\u0026#34;Hello, World!\u0026#34;); } 函式的參數、回傳值、呼叫函式等等，跟大部分程式語言的概念是一樣的，\n這裡就不再進一步介紹了。\n比較值得注意的是我們可以在參數後方加上 -\u0026gt; 來指定回傳值的型別。\n1 2 3 fn add(x: i32, y: i32) -\u0026gt; i32 { return x + y; } 並且在函式當中的最後一個陳述式，在不加上分號的情況下，會自動作為回傳值被回傳。\n1 2 3 4 5 6 7 fn add(x: i32, y: i32) -\u0026gt; i32 { x + y } fn main() { println!(\u0026#34;{}\u0026#34;, add(1, 2)); // 3 } 陳述式與表達式 Rust 是基於表達式的語言（expression-based），因此在這個小節，我們要介紹的是陳述式和表達式的差別。\n陳述式（Statements） 陳述式代表著程式當中的指令，這個指令不會回傳任何的數值。 像是：\n1 let x = 12; 表達式（Expressions） 而表達式則是指程式當中的計算結果，這個計算結果會回傳一個數值。\n我們來看看這個範例：\n1 2 3 4 5 6 7 8 fn main() { let x = { let a = 12; a \u0026lt;\u0026lt; 1 } println!(\u0026#34;{}\u0026#34;, x); // 24 } 這個範例中的 {}，如同函式的回傳一樣，就是表達式的一部分。\n而其實在前幾個小節當中，我們已經看到了表達式，像是：\n1 2 3 match x { ... } 還有 if 條件判斷的表達式，這些可以產生一個數值的指令，也是表達式的一種。\n參考資料 Rust Official Documentation Book, Section 3 ","date":"2025-04-22T22:42:36+08:00","image":"https://blog.mirumo.net/post/rustlearnwithai2/cover_hu6733501137486509058.png","permalink":"https://blog.mirumo.net/post/rustlearnwithai2/","title":"用 AI 加速學習：Rust 基本語法與資料型態"},{"content":"Rust 是什麼？ Rust 是一個邊一行的程式語言，主打安全性、速度、並行處理。 相對於其他程式語言來說 Rust 可以說是非常年輕的， 2012 年 1 月懷上的它，直到 2015 年 5 月 15 日才出生。\n安裝 Rust 在 Rust 個官方網站中， 推薦了使用 rustup 來安裝 Rust。 rustup 是 Rust 官方提供的工具鏈安裝與管理器， 可以讓你方便地安裝 Rust、切換不同版本。 Unix-like 作業系統可以執行以下指令來安裝 rustup：\n1 $ curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 接這我們就可以使用 rustup 指令來安裝 Rust。\n1 $ rustup install stable 這個指令會幫我們下載 Rust 的穩定版本，與相關的工具（包含 rustfmt、cargo 等）。\nHello Rust 安裝完之後，可以使用 rustc --version 指令來檢查是否安裝成功。 這是 Rust 的編譯器，可以用來編譯 Rust 程式。\n接這我們就可以開始寫 Rust 程式了！ 首先建立一個檔案 hello.rs，並在裡面寫入以下程式：\n1 2 3 fn main() { println!(\u0026#34;Hello, Rust!\u0026#34;); } 其中：\nfn 是建立函數的關鍵字。 main 是函數的名稱，在 Rust 當中 main 作為整個程式的入口。 println! 以 ! 結尾在 Rust 中表示巨集（macro）。 \u0026quot;Hello, Rust!\u0026quot; 是要印出的字串。 接著使用以下指令來編譯程式：\n1 $ rustc hello.rs 這樣就可以編譯出一個與檔案名稱相同的執行檔了。 我們試著執行這個執行檔。\n1 2 $ ./hello Hello, Rust! Cargo Cargo 是 Rust 的建置工具與套件管理工具， 大多數專案都會透過 Cargo 進行管理。\n透過 rustup 安裝 Rust 時，Cargo 也會一併安裝。\n首現我們先用 Cargo 建立一個專案：\n1 $ cargo new hello_cargo 這時 cargo 會幫我們建立一個結構如下的資料夾：\n1 2 3 4 5 6 7 hello_cargo ├── .git │ └── (...) ├── src │ └── main.rs ├── Cargo.toml └── .gitignore 其中，main.rs 是程式的入口，Cargo.toml 是專案的配置檔。\n進入專案資料夾後，我們可以打開 src/main.rs，並且將剛剛的程式寫入這個檔案中。 接著透過 Cargo 指令來執行專案。Cargo 會自動編譯原始碼並執行可執行檔。\n1 2 3 4 5 $ cargo run Compiling hello_rust v0.1.0 (/playground/hello_rust) Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.17s Running `target/debug/hello_rust` Hello, world! 這個指令執行直，會先編譯 src/main.rs，再執行程式。 這個編譯的結果，會生成在路徑 target/debug/hello_rust 當中。\n我們也可以編譯但不執行檔案：\n1 $ cargo build 或是僅檢查程式的語法錯誤，但不編譯該程式：\n1 $ cargo check 最後，當我們完成了專案時，可以使用 release 模式進行最佳化編譯。\n1 $ cargo build --release 這會產生效能更好的執行檔，放在 target/release 目錄中。雖然編譯時間會增加，但執行效率會大幅提升。\n參考資料 Rust Official Documentation Book, Section 1 Rust in 100 Seconds ","date":"2025-03-29T22:58:27+08:00","image":"https://blog.mirumo.net/post/rustlearnwithai1/cover_hu10683313413428465491.png","permalink":"https://blog.mirumo.net/post/rustlearnwithai1/","title":"用 AI 加速學習：Rust 語言簡介與環境設置"},{"content":"大家都說 Rust 很難，上手的難度簡直高得讓人望而卻步。\n語法跟概念堆得跟魔王塔一樣高，還暗藏陷阱，一個不注意就直接卡關回城重練。\n我一開始滿腔熱血地衝進去，結果三秒鐘後腦袋就冒煙。🤯\n。。。\n所以我召喚來了 Ai 來進攻 Rust 編譯器。\n「請幫我規劃一個完整的 rust 學習地圖，分為多個小節，並且以條列的方式點出該小節的重要概念。提供我可以一步一步的學習 rust 語言的規劃，並且在每個小節都設計練習題，讓我更加熟練 rust。」\nRust 語言簡介與環境設置 重要概念： Rust 語言特色與優點（安全性、速度、並發） 安裝 Rust：使用 Rustup 工具 Cargo：Rust 的建構與套件管理工具 練習題： 安裝 Rust 與 Cargo，並確認安裝是否成功。 使用 Cargo 建立你的第一個專案，編寫並執行 \u0026ldquo;Hello, world!\u0026rdquo; 範例。 基本語法與資料型態 重要概念： 變數與不可變性（預設不可變，使用 mut 開啟可變性） 基本資料型態：整數、浮點數、布林、字串、陣列、元組 函數定義與呼叫 條件判斷（if/else）與迴圈（loop、while、for） 練習題： 撰寫一個簡單的計算機程式，利用條件判斷選擇不同運算。 使用迴圈印出 1 至 10 的數字，嘗試用不同迴圈結構實作。 所有權、借用與生命週期 重要概念： 所有權系統：每個值都有且僅有一個所有者 借用：不可變借用與可變借用，理解借用規則 生命週期：如何告知編譯器資料有效範圍 練習題： 撰寫函數傳遞字串與數值，觀察所有權的轉移與借用。 嘗試修改程式碼，故意引發借用錯誤，並依照編譯器提示進行修正。 結構、列舉與模式匹配 重要概念： 結構體（Structs）：定義與使用自訂資料型態。 列舉（Enums）：定義有限狀態或選項集合。 模式匹配（match）：根據模式做分支處理。 Option 與 Result：處理可能缺失或錯誤的值。 練習題： 定義一個描述幾何圖形（例如圓形、矩形）的列舉，並使用 match 輸出相應的面積計算。 實作一個簡單的錯誤處理範例，使用 Option 或 Result 處理可能的錯誤狀況。 泛型、Traits 與實作 重要概念： 泛型：使函數或結構體能處理不同型態資料。 Trait：定義共通行為，並實作於不同型態。 標準 trait（如 Debug、Clone、PartialEq）與自定義 trait。 練習題： 寫一個泛型資料結構（例如 Stack 或 Queue），並為其實作 Debug trait。 定義一個自訂 trait 並實作於至少兩個不同型態，嘗試在程式中使用多態性。 模組系統與包管理 重要概念： 模組（mod）：如何組織程式碼與資料夾結構。 Crate：Rust 的編譯單位。 Cargo.toml：管理專案依賴與設定。 練習題： 建立一個包含多個模組的小專案，嘗試在不同模組間共享函數與變數。 在 Cargo.toml 中加入第三方 crate（例如 serde），並寫一個小範例使用該庫進行資料序列化。 錯誤處理與 panic 重要概念： Result 型態：成功與錯誤狀況的處理方式。 Option 型態：處理可能缺失的值。 錯誤傳播（使用 ? 運算子）與 panic 機制。 練習題： 撰寫一個檔案 I/O 範例，利用 Result 處理讀取檔案過程中的錯誤。 改寫函數，從使用 unwrap 改為正確的錯誤傳播與處理。 併發程式設計 重要概念： 線程（threads）：如何建立與管理線程。 併發安全：Send 與 Sync 特質。 Mutex 與 Channel：保護共享資源與線程間通訊。 練習題： 撰寫一個多線程程式，使用 Mutex 保護共用計數器。 使用 Channel 實作生產者-消費者模型。 智能指標與內存管理 重要概念： Box：在堆上分配記憶體。 Rc 與 Arc：多重所有權與跨線程安全共享。 RefCell 與 Cell：在編譯時期無法確定所有權時提供內部可變性。 練習題： 撰寫一個簡單的樹狀結構，利用 Rc 與 RefCell 管理節點間的參考。 嘗試使用 Arc 在多線程中共享不可變資料。 宏與程式自動化 重要概念： 宏（macro_rules!）：編譯時期程式碼生成與重用。 Attribute 宏：透過屬性標記自動生成程式碼。 程式碼縮減與重構。 練習題： 撰寫一個簡單的宏，生成重複性程式碼（例如簡化多個相似函數的定義）。 使用宏改善現有程式碼的可讀性與重用性。 測試與除錯 重要概念： 單元測試（Unit Test）：模組內測試撰寫與執行。 整合測試（Integration Test）：跨模組與專案測試。 除錯技巧：使用 println!、logging 與除錯工具。 練習題： 為各個模組撰寫單元測試，確保邏輯正確。 撰寫整合測試，模擬使用者行為驗證專案整體運作。 Rust 生態系統與進階主題 重要概念： crates.io：如何搜尋並使用第三方庫。 WebAssembly 與嵌入式應用：Rust 的應用範疇擴展。 非同步程式設計（async/await）：處理非同步 I/O 與高效併發。 外部函式介面（FFI）：與 C/C++ 等語言整合。 練習題： 搜尋並整合一個第三方庫，撰寫一個簡單專案（如 Web API 或 CLI 工具）。 編寫一個使用 async/await 的非同步網路請求範例。 ","date":"2025-03-29T22:58:27+08:00","image":"https://blog.mirumo.net/post/rustlearnwithai0/cover_hu11584735424367520306.png","permalink":"https://blog.mirumo.net/post/rustlearnwithai0/","title":"用 AI 加速學習：規劃 Rust 學習路徑"},{"content":"（GPT 取的標題 🤪）\n最近在逛 Apple 官網的時候，看到了 2 萬多塊 的 MacBook Air M2 整修品， 剛好我也快要受不了女朋友的電腦了，索性就下單了 ~~\n不過她是第一次用 Mac，於是我就先來幫她設定啦， 順便分享一下我常使用的 Mac 工具。\n終端機 iTerm2 身為一個軟體工程師（她應該之後也會是吧？！），終端機是我們很重要的工具。 iTerm2 是一個終端機模擬器（Terminal emulator），可以當作是macOS 上的強化版終端機， 提供比內建終端更強大的功能、客製化選項與提升生產力的特性，很適合開發者、系統管理員及資深使用者使用。\ntmux tmux（Terminal Multiplexer）是一款終端多工管理工具， 允許你在單一終端會話（Session）中管理多個視窗與面板， 並支援背景運行、遠端連線保持、分割視窗等功能。\n整合開發環境（IDE) Neovim Neovim 是 Vim 的改進版，目標是現代化、可擴充、提升效能， 並提供更友善的插件開發與 Lua 配置。 相較於傳統 Vim，Neovim 在 外掛系統、LSP（Language Server Protocol）、內建終端、多執行緒處理等方面有更好的支援， 使其成為現代開發者的首選終端編輯器。\n雖然這東西對初學的人來說很不友善，但她在 VSCode 裡也都用 Vim 模式，應該也沒什麼問題（吧？！）\nCursor Cursor 是由 VSCode Fork 出來的 IDE，它提供了生成式 AI 來幫助開發者寫程式。 只要打上需求，就自動寫出你要的功能，上班按按 Tab 就可以下班了 XD\nZed Zed 是一款由 Rust 開發的 IDE，比起 VSCode 速度可是快了非常的多。 它的一大亮點是它的即時協作功能，使得團隊中的多位開發者可以同時在同一個代碼庫中進行編輯。 同時也整合了 LLM 提供開發的協助。\nMarkdown 編輯器 這個部分最主要是作為筆記用的工具，而我對筆記工具沒什麼要求，支援 Markdown 輸出就行。\nZettlr 作為開源的推廣者，Zettlr 是我非常喜歡的一款開源 Markdown 編輯器， 畫面乾淨、簡單又容易上手。並且內建對 LaTeX、HTML 等格式的良好支援， 使其成為學術寫作、技術寫作、程式碼文檔等領域的理想選擇。\nObsidian Obsidian 是一款強大的知識管理和筆記整理工具， 可以使用 Markdown 格式進行筆記創建，並允許用戶將各個筆記通過雙向鏈接進行連接， 這使得它非常適合進行思維導圖、知識圖譜或者個人知識庫的管理。\n瀏覽器 Arc Arc 是一款由 The Browser Company 開發的創新型瀏覽器， 旨在提供一個更加現代化且以生產力為導向的瀏覽器體驗。 Arc 打破了傳統瀏覽器的界限，設計上注重簡潔、直觀的用戶界面，並致力於提升使用者的工作流程效率。\nZen Browser Zen Browser 的設計與 Arc 非常相似， 與 Arc 最大的不同是，Zen Browser 基於 Mozilla Firefox。\n命令行工具 bat bat 是一個 cat 替代品，用於在命令行中顯示文件內容。 它提供了語法辨識、行號顯示、分頁功能等，比傳統的 cat 更加直觀。\nfzf fzf 是一個模糊搜尋工具， 可以在終端機中，以選單的方式搜尋檔案、指令紀錄、運行的程式\u0026hellip;等。\n也有非常多的工具可以與 fzf 結合，讓搜尋變得更加靈活。\nripgrep ripgrep 是一款超快速的檔案內容搜尋工具， 用來取代傳統的 grep。 它比 grep、ack、ag（The Silver Searcher）更快，並且內建遞迴搜尋、忽略 .gitignore 規則。\ndelta delta 是一款美觀的 Git Diff Viewer，用來取代 git diff。 提供語法辨識、側邊欄、行內變更顯示，讓 git diff 變得更清晰易讀。\n","date":"2025-02-23T13:22:01+08:00","image":"https://blog.mirumo.net/post/commandlinetoolshare/cover_hu1515739980146205539.png","permalink":"https://blog.mirumo.net/post/commandlinetoolshare/","title":"用對 Mac 工具，連貓都能寫程式"},{"content":"前陣子，我的女朋友帶著一臉焦急來找我求救，說她需要完成一個關於螞蟻演算法的報告，但完全不知道怎麼做，希望我幫幫他。「作業要自己做！」看了一下我的行程然後跟她說了這句話。\n。\n。\n。\n「好啦！」\n（專案 PR 我還沒 Review 完耶 QAQ ~）\n。\n。\n。\n❗️❗️ 女朋友表示：以上純屬虛構 ❗️❗️\n什麼是螞蟻演算法？ 螞蟻演算法（Ant Colony Optimization, ACO）是一種受自然界啟發的優化演算法， 其靈感來源於螞蟻群體尋找食物時的集體行為。 這個演算法由義大利科學家 Marco Dorigo 在 1992 年提出， 並在後續的研究中被廣泛應用於解決各種複雜的組合優化問題。\n螞蟻在探索食物時，會在經過的路徑上釋放費洛蒙， 費洛蒙的濃度越高，其他螞蟻選擇這條路徑的機率也越大。 然而，費洛蒙會隨時間揮發，因此如果一條路徑較長或效率較低， 費洛蒙的吸引力會逐漸減弱。 相反的，短而有效的路徑會因為更多螞蟻的選擇而累積更多費洛蒙，最終成為群體的最優選擇。螞蟻演算法的核心在於模擬這一過程，通過不斷迭代來逼近最優解。\n螞蟻演算法的步驟 螞蟻演算法通過以下幾個步驟來模擬螞蟻的行為：\n初始化：設定蟻群的活動空間，這個空間通常用來代表問題的解決範圍或解空間。同時，也會設定費洛蒙的初始濃度和其他參數。\n解的構建：蟻群中的螞蟻開始在活動空間中隨機遊走，根據費洛蒙濃度和啟發式資訊選擇路徑。\n費洛蒙更新：每當一隻螞蟻完成了一次解的建構，演算法便會更新這段路徑上的費洛蒙值。有效的路徑會獲得更多的費洛蒙，反之則會減少。\n迭代：重複步驟2和3，直到達到停止條件，如固定的迭代次數或解的改進程度不再顯著。\n通過這些步驟，螞蟻演算法能夠在解空間中發現隱藏的最佳解，並適應各種複雜的問題。\n1 2 3 4 5 6 7 procedure ACO_MetaHeuristic is while not terminated do generateSolutions() daemonActions() pheromoneUpdate() repeat end procedure 螞蟻的路徑選擇 螞蟻在選擇路徑時，主要依賴於費洛蒙的濃度。 具體來說，當濃度越高時，螞蟻選擇該路徑的機率也越高， 我們用以下公式來表示螞蟻從當前節點 \\(i\\) 選擇下一個節點 \\(j\\) 的機率：\n$$ P_{ij} = \\frac{\\tau_{ij}^{\\alpha} \\eta_{ij}^{\\beta}}{\\sum_{k \\in N_i} \\tau_{ik}^{\\alpha} \\eta_{ik}^{\\beta}} $$其中：\n\\(\\tau_{ij}\\) 代表從節點 \\(i\\) 到節點 \\(j\\) 的費洛蒙濃度。 \\(\\eta_{ij}\\) 代表啟發式資訊（該問題的結果優劣），通常是距離的倒數 \\(\\frac{1}{d_{ij}}\\)。 \\(\\alpha\\) 和 \\(\\beta\\) 是兩個參數，分別控制費洛蒙與啟發式資訊的影響程度。 \\(N_i\\) 為當前螞蟻可選擇的鄰近節點集合。 當 \\(\\alpha\\) 值較大時，螞蟻更傾向於選擇費洛蒙濃度高的路徑， 而當 \\(\\beta\\) 值較大時，則更強調啟發式資訊（如較短的距離）。 適當調整這些參數，能夠提升演算法的性能。\n費洛蒙的更新 費洛蒙更新機制確保了有效路徑的增強與次優路徑的淘汰。更新過程通常包含兩個部分：\n費洛蒙蒸發：為了避免過早收斂至局部最優解，費洛蒙會隨時間逐漸減少，其衰減公式為：\n$$ \\tau_{ij} \\leftarrow (1 - \\rho) \\cdot \\tau_{ij} $$其中，\\(\\rho\\) 為蒸發率（0 \u0026lt; \\(\\rho\\) \u0026lt; 1），用來控制費洛蒙的衰減速度。\n費洛蒙增強：當螞蟻成功找到解後，根據路徑長度分配新的費洛蒙：\n$$ \\tau_{ij} \\leftarrow \\tau_{ij} + \\sum_{k=1}^{m} \\Delta \\tau_{ij}^{k} $$其中，\\(\\Delta \\tau_{ij}^{k}\\) 為第 \\(k\\) 隻螞蟻在路徑上的費洛蒙貢獻， 通常與解的品質相關，例如：\\(\\Delta \\tau_{ij}^{k} = \\frac{Q}{L_k}\\)。\n\\(Q\\) 為常數，用來調整費洛蒙的強度。 \\(L_k\\) 為第 隻螞蟻找到的解的路徑長度，越短的路徑獲得的費洛蒙越多。 實作範例 最後，為了展示螞蟻演算法的應用，這裡以旅行推銷員問題（TSP）為例。 TSP 的目標是尋找最短路徑，使旅行推銷員能夠走訪所有城市且最終返回起點。\n參考資料 wikipedia - Ant colony optimization algorithms ","date":"2025-01-05T23:29:49+08:00","image":"https://blog.mirumo.net/post/antcolonyoptimization/cover_hu1922144956379165581.png","permalink":"https://blog.mirumo.net/post/antcolonyoptimization/","title":"螞蟻演算法 - Python 範例"},{"content":"在資訊科技領域中，「Hello World」經常被用來作為測試開發環境是否正確設置的一種方式，透過將這段文字打印或顯示出來，開發者能迅速確認系統的基本運行狀態。因此我利用這篇文章，作為整個部落格的第一篇文。\nHello World 的起源 「Hello World」這個程式的歷史可以追溯到 1970 年代。《The C Programming Language》（C 語言程式設計）這本經典書籍中，Brian Kernighan 和 Dennis Ritchie 使用了一個簡單的範例來介紹如何在螢幕上顯示文字，而這個範例就是「Hello, World!」。由於其簡單易懂且不容易出錯，它很快成為程式設計入門的標誌。\n「Hello, World」的概念可以追溯到 Brian Kernighan 在 1974 年的內部技術手冊 《Programming in C: A Tutorial》， 他在該手冊中用 B 語言（C 語言的前身）展示了類似的範例程式碼：\n1 2 3 main() { printf(\u0026#34;hello, world\u0026#34;); } Hugo 功能測試 一般標記 斜體 *斜體*\n粗體 **粗體**\n刪除線 ~~刪除線~~\n標記 ==標記==\n底線 ++底線++\n上標 上^標^\n下標 下~標~\n程式碼 一般顯示 1 #define hugo 程式碼標記 1package main 2 3import \u0026#34;fmt\u0026#34; 4 5func main() { 6 for i := 0; i \u0026lt; 3; i++ { 7 fmt.Println(\u0026#34;Value of i:\u0026#34;, i) 8 } 9} Latex Math \\[ \\begin{aligned} KL(\\hat{y} || y) \u0026= \\sum_{c=1}^{M}\\hat{y}_c \\log{\\frac{\\hat{y}_c}{y_c}} \\\\ JS(\\hat{y} || y) \u0026= \\frac{1}{2}(KL(y||\\frac{y+\\hat{y}}{2}) + KL(\\hat{y}||\\frac{y+\\hat{y}}{2})) \\end{aligned} \\]This is an inline \\(a^*=x-b^*\\) equation.\n參考資料 wikipedia - \u0026ldquo;Hello, World!\u0026rdquo; program ","date":"2025-01-04T22:59:50+08:00","permalink":"https://blog.mirumo.net/post/helloworld/","title":"Hello World"}]