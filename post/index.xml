<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Mirumo's Blog</title><link>https://blog.mirumo.net/post/</link><description>Recent content in Posts on Mirumo's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Sun, 23 Feb 2025 13:22:01 +0800</lastBuildDate><atom:link href="https://blog.mirumo.net/post/index.xml" rel="self" type="application/rss+xml"/><item><title>用對 Mac 工具，連貓都能寫程式</title><link>https://blog.mirumo.net/post/commandlinetoolshare/</link><pubDate>Sun, 23 Feb 2025 13:22:01 +0800</pubDate><guid>https://blog.mirumo.net/post/commandlinetoolshare/</guid><description>&lt;img src="https://blog.mirumo.net/post/commandlinetoolshare/cover.png" alt="Featured image of post 用對 Mac 工具，連貓都能寫程式" />&lt;p>（GPT 取的標題 🤪）&lt;/p>
&lt;p>最近在逛 Apple 官網的時候，看到了 2 萬多塊 的 MacBook Air M2 整修品，
剛好我也快要受不了女朋友的電腦了，索性就下單了 ~~&lt;/p>
&lt;p>不過她是第一次用 Mac，於是我就先來幫她設定啦，
順便分享一下我常使用的 Mac 工具。&lt;/p>
&lt;h2 id="終端機">終端機
&lt;/h2>&lt;h3 id="iterm2">iTerm2
&lt;/h3>&lt;p>身為一個軟體工程師（她應該之後也會是吧？！），終端機是我們很重要的工具。
&lt;a class="link" href="https://iterm2.com/" target="_blank" rel="noopener"
>&lt;strong>iTerm2&lt;/strong>&lt;/a> 是一個終端機模擬器（Terminal emulator），可以當作是macOS 上的&lt;strong>強化版終端機&lt;/strong>，
提供比內建終端更強大的功能、客製化選項與提升生產力的特性，很適合開發者、系統管理員及資深使用者使用。&lt;/p>
&lt;h3 id="tmux">tmux
&lt;/h3>&lt;p>&lt;a class="link" href="https://github.com/tmux/tmux/wiki" target="_blank" rel="noopener"
>&lt;strong>tmux&lt;/strong>&lt;/a>（Terminal Multiplexer）是一款終端多工管理工具，
允許你在單一終端會話（Session）中管理多個視窗與面板，
並支援背景運行、遠端連線保持、分割視窗等功能。&lt;/p>
&lt;h2 id="整合開發環境ide">整合開發環境（IDE)
&lt;/h2>&lt;h3 id="neovim">Neovim
&lt;/h3>&lt;p>&lt;a class="link" href="https://neovim.io/" target="_blank" rel="noopener"
>&lt;strong>Neovim&lt;/strong>&lt;/a> 是 Vim 的改進版，目標是現代化、可擴充、提升效能，
並提供更友善的插件開發與 Lua 配置。
相較於傳統 Vim，Neovim 在 外掛系統、LSP（Language Server Protocol）、內建終端、多執行緒處理等方面有更好的支援，
使其成為現代開發者的首選終端編輯器。&lt;/p>
&lt;p>雖然這東西對初學的人來說很不友善，但她在 VSCode 裡也都用 Vim 模式，應該也沒什麼問題（吧？！）&lt;/p>
&lt;h3 id="cursor">Cursor
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.cursor.com/" target="_blank" rel="noopener"
>&lt;strong>Cursor&lt;/strong>&lt;/a> 是由 VSCode Fork 出來的 IDE，它提供了生成式 AI 來幫助開發者寫程式。
只要打上需求，就自動寫出你要的功能，上班按按 &lt;code>Tab&lt;/code> 就可以下班了 XD&lt;/p>
&lt;h3 id="zed">Zed
&lt;/h3>&lt;p>&lt;a class="link" href="https://zed.dev/" target="_blank" rel="noopener"
>&lt;strong>Zed&lt;/strong>&lt;/a> 是一款由 Rust 開發的 IDE，比起 VSCode 速度可是快了非常的多。
它的一大亮點是它的即時協作功能，使得團隊中的多位開發者可以同時在同一個代碼庫中進行編輯。
同時也整合了 LLM 提供開發的協助。&lt;/p>
&lt;h2 id="markdown-編輯器">Markdown 編輯器
&lt;/h2>&lt;p>&lt;small>這個部分最主要是作為筆記用的工具，而我對筆記工具沒什麼要求，支援 Markdown 輸出就行。&lt;/small>&lt;/p>
&lt;h3 id="zettlr">Zettlr
&lt;/h3>&lt;p>作為開源的推廣者，&lt;a class="link" href="https://www.zettlr.com/" target="_blank" rel="noopener"
>&lt;strong>Zettlr&lt;/strong>&lt;/a> 是我非常喜歡的一款開源 Markdown 編輯器，
畫面乾淨、簡單又容易上手。並且內建對 LaTeX、HTML 等格式的良好支援，
使其成為學術寫作、技術寫作、程式碼文檔等領域的理想選擇。&lt;/p>
&lt;h3 id="obsidian">Obsidian
&lt;/h3>&lt;p>&lt;a class="link" href="https://obsidian.md/" target="_blank" rel="noopener"
>&lt;strong>Obsidian&lt;/strong>&lt;/a> 是一款強大的知識管理和筆記整理工具，
可以使用 Markdown 格式進行筆記創建，並允許用戶將各個筆記通過雙向鏈接進行連接，
這使得它非常適合進行思維導圖、知識圖譜或者個人知識庫的管理。&lt;/p>
&lt;h2 id="瀏覽器">瀏覽器
&lt;/h2>&lt;h3 id="arc">Arc
&lt;/h3>&lt;p>&lt;a class="link" href="https://arc.net/" target="_blank" rel="noopener"
>&lt;strong>Arc&lt;/strong>&lt;/a> 是一款由 The Browser Company 開發的創新型瀏覽器，
旨在提供一個更加現代化且以生產力為導向的瀏覽器體驗。
Arc 打破了傳統瀏覽器的界限，設計上注重簡潔、直觀的用戶界面，並致力於提升使用者的工作流程效率。&lt;/p>
&lt;h3 id="zen-browser">Zen Browser
&lt;/h3>&lt;p>&lt;a class="link" href="https://zen-browser.app/" target="_blank" rel="noopener"
>&lt;strong>Zen Browser&lt;/strong>&lt;/a> 的設計與 Arc 非常相似，
與 Arc 最大的不同是，Zen Browser 基於 Mozilla Firefox。&lt;/p>
&lt;h2 id="命令行工具">命令行工具
&lt;/h2>&lt;h3 id="bat">bat
&lt;/h3>&lt;p>&lt;a class="link" href="https://github.com/sharkdp/bat" target="_blank" rel="noopener"
>&lt;strong>bat&lt;/strong>&lt;/a> 是一個 &lt;code>cat&lt;/code> 替代品，用於在命令行中顯示文件內容。
它提供了語法辨識、行號顯示、分頁功能等，比傳統的 cat 更加直觀。&lt;/p>
&lt;h3 id="fzf">fzf
&lt;/h3>&lt;p>&lt;a class="link" href="https://junegunn.github.io/fzf/" target="_blank" rel="noopener"
>&lt;strong>fzf&lt;/strong>&lt;/a> 是一個模糊搜尋工具，
可以在終端機中，以選單的方式搜尋檔案、指令紀錄、運行的程式&amp;hellip;等。&lt;/p>
&lt;p>也有非常多的工具可以與 fzf 結合，讓搜尋變得更加靈活。&lt;/p>
&lt;h3 id="ripgrep">ripgrep
&lt;/h3>&lt;p>&lt;a class="link" href="https://github.com/BurntSushi/ripgrep" target="_blank" rel="noopener"
>&lt;strong>ripgrep&lt;/strong>&lt;/a> 是一款超快速的檔案內容搜尋工具， 用來取代傳統的 grep。
它比 grep、ack、ag（The Silver Searcher）更快，並且內建遞迴搜尋、忽略 &lt;code>.gitignore&lt;/code> 規則。&lt;/p>
&lt;h3 id="delta">delta
&lt;/h3>&lt;p>&lt;a class="link" href="https://github.com/dandavison/delta" target="_blank" rel="noopener"
>&lt;strong>delta&lt;/strong>&lt;/a> 是一款美觀的 Git Diff Viewer，用來取代 git diff。
提供語法辨識、側邊欄、行內變更顯示，讓 git diff 變得更清晰易讀。&lt;/p></description></item><item><title>螞蟻演算法 - Python 範例</title><link>https://blog.mirumo.net/post/antcolonyoptimization/</link><pubDate>Sun, 05 Jan 2025 23:29:49 +0800</pubDate><guid>https://blog.mirumo.net/post/antcolonyoptimization/</guid><description>&lt;img src="https://blog.mirumo.net/post/antcolonyoptimization/cover.png" alt="Featured image of post 螞蟻演算法 - Python 範例" />&lt;p>前陣子，我的女朋友帶著一臉焦急來找我求救，說她需要完成一個關於&lt;strong>螞蟻演算法&lt;/strong>的報告，但完全不知道怎麼做，希望我幫幫他。「作業要自己做！」看了一下我的行程然後跟她說了這句話。&lt;/p>
&lt;p>。&lt;br>
。&lt;br>
。&lt;/p>
&lt;p>「好啦！」&lt;br>
（專案 PR 我還沒 Review 完耶 QAQ ~）&lt;/p>
&lt;p>。&lt;br>
。&lt;br>
。&lt;/p>
&lt;p>❗️❗️ 女朋友表示：以上純屬虛構 ❗️❗️&lt;/p>
&lt;h2 id="什麼是螞蟻演算法">什麼是螞蟻演算法？
&lt;/h2>&lt;p>螞蟻演算法（Ant Colony Optimization, ACO）是一種受自然界啟發的優化演算法，
其靈感來源於螞蟻群體尋找食物時的集體行為。
這個演算法由義大利科學家 Marco Dorigo 在 1992 年提出，
並在後續的研究中被廣泛應用於解決各種複雜的組合優化問題。&lt;/p>
&lt;p>螞蟻在探索食物時，會在經過的路徑上釋放費洛蒙，
費洛蒙的濃度越高，其他螞蟻選擇這條路徑的機率也越大。
然而，費洛蒙會隨時間揮發，因此如果一條路徑較長或效率較低，
費洛蒙的吸引力會逐漸減弱。
相反的，短而有效的路徑會因為更多螞蟻的選擇而累積更多費洛蒙，最終成為群體的最優選擇。螞蟻演算法的核心在於模擬這一過程，通過不斷迭代來逼近最優解。&lt;/p>
&lt;h2 id="螞蟻演算法的步驟">螞蟻演算法的步驟
&lt;/h2>&lt;p>螞蟻演算法通過以下幾個步驟來模擬螞蟻的行為：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>初始化：設定蟻群的活動空間，這個空間通常用來代表問題的解決範圍或解空間。同時，也會設定費洛蒙的初始濃度和其他參數。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>解的構建：蟻群中的螞蟻開始在活動空間中隨機遊走，根據費洛蒙濃度和啟發式資訊選擇路徑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>費洛蒙更新：每當一隻螞蟻完成了一次解的建構，演算法便會更新這段路徑上的費洛蒙值。有效的路徑會獲得更多的費洛蒙，反之則會減少。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>迭代：重複步驟2和3，直到達到停止條件，如固定的迭代次數或解的改進程度不再顯著。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>通過這些步驟，螞蟻演算法能夠在解空間中發現隱藏的最佳解，並適應各種複雜的問題。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">procedure ACO_MetaHeuristic is
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> while not terminated do
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> generateSolutions()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> daemonActions()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> pheromoneUpdate()
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> repeat
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">end procedure
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="螞蟻的路徑選擇">螞蟻的路徑選擇
&lt;/h2>&lt;p>螞蟻在選擇路徑時，主要依賴於費洛蒙的濃度。
具體來說，當濃度越高時，螞蟻選擇該路徑的機率也越高，
我們用以下公式來表示螞蟻從當前節點 \(i\) 選擇下一個節點 \(j\) 的機率：&lt;/p>
$$
P_{ij} = \frac{\tau_{ij}^{\alpha} \eta_{ij}^{\beta}}{\sum_{k \in N_i} \tau_{ik}^{\alpha} \eta_{ik}^{\beta}}
$$&lt;p>其中：&lt;/p>
&lt;ul>
&lt;li>\(\tau_{ij}\) 代表從節點 \(i\) 到節點 \(j\) 的費洛蒙濃度。&lt;/li>
&lt;li>\(\eta_{ij}\) 代表啟發式資訊（該問題的結果優劣），通常是距離的倒數 \(\frac{1}{d_{ij}}\)。&lt;/li>
&lt;li>\(\alpha\) 和 \(\beta\) 是兩個參數，分別控制費洛蒙與啟發式資訊的影響程度。&lt;/li>
&lt;li>\(N_i\) 為當前螞蟻可選擇的鄰近節點集合。&lt;/li>
&lt;/ul>
&lt;p>當 \(\alpha\) 值較大時，螞蟻更傾向於選擇費洛蒙濃度高的路徑，
而當 \(\beta\) 值較大時，則更強調啟發式資訊（如較短的距離）。
適當調整這些參數，能夠提升演算法的性能。&lt;/p>
&lt;h2 id="費洛蒙的更新">費洛蒙的更新
&lt;/h2>&lt;p>費洛蒙更新機制確保了有效路徑的增強與次優路徑的淘汰。更新過程通常包含兩個部分：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>費洛蒙蒸發：為了避免過早收斂至局部最優解，費洛蒙會隨時間逐漸減少，其衰減公式為：&lt;/p>
$$
\tau_{ij} \leftarrow (1 - \rho) \cdot \tau_{ij}
$$&lt;p>其中，\(\rho\) 為蒸發率（0 &amp;lt; \(\rho\) &amp;lt; 1），用來控制費洛蒙的衰減速度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>費洛蒙增強：當螞蟻成功找到解後，根據路徑長度分配新的費洛蒙：&lt;/p>
$$
\tau_{ij} \leftarrow \tau_{ij} + \sum_{k=1}^{m} \Delta \tau_{ij}^{k}
$$&lt;p>其中，\(\Delta \tau_{ij}^{k}\) 為第 \(k\) 隻螞蟻在路徑上的費洛蒙貢獻，
通常與解的品質相關，例如：\(\Delta \tau_{ij}^{k} = \frac{Q}{L_k}\)。&lt;/p>
&lt;ul>
&lt;li>\(Q\) 為常數，用來調整費洛蒙的強度。&lt;/li>
&lt;li>\(L_k\) 為第 隻螞蟻找到的解的路徑長度，越短的路徑獲得的費洛蒙越多。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="實作範例">實作範例
&lt;/h2>&lt;p>最後，為了展示螞蟻演算法的應用，這裡以旅行推銷員問題（&lt;a class="link" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" target="_blank" rel="noopener"
>TSP&lt;/a>）為例。
TSP 的目標是尋找最短路徑，使旅行推銷員能夠走訪所有城市且最終返回起點。&lt;/p>
&lt;p>&lt;a class="link" href="https://github.com/mirumodapon/ant-colony-optimization-python-example" target="_blank" rel="noopener"
>&lt;img src="https://opengraph.githubassets.com/29fd19c671af65614e5fae3b201cdc010df3618ae56b978e523185004c914d7c/mirumodapon/ant-colony-optimization-python-example"
loading="lazy"
>&lt;/a>&lt;/p>
&lt;hr>
&lt;h4>參考資料&lt;/h4>
&lt;ul>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Ant_colony_optimization_algorithms" target="_blank" rel="noopener"
>wikipedia - Ant colony optimization algorithms&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Hello World</title><link>https://blog.mirumo.net/post/helloworld/</link><pubDate>Sat, 04 Jan 2025 22:59:50 +0800</pubDate><guid>https://blog.mirumo.net/post/helloworld/</guid><description>&lt;p>在資訊科技領域中，「Hello World」經常被用來作為測試開發環境是否正確設置的一種方式，透過將這段文字打印或顯示出來，開發者能迅速確認系統的基本運行狀態。因此我利用這篇文章，作為整個部落格的第一篇文。&lt;/p>
&lt;h2 id="hello-world-的起源">Hello World 的起源
&lt;/h2>&lt;p>「Hello World」這個程式的歷史可以追溯到 1970 年代。《The C Programming Language》（C 語言程式設計）這本經典書籍中，Brian Kernighan 和 Dennis Ritchie 使用了一個簡單的範例來介紹如何在螢幕上顯示文字，而這個範例就是「Hello, World!」。由於其簡單易懂且不容易出錯，它很快成為程式設計入門的標誌。&lt;/p>
&lt;p>「Hello, World」的概念可以追溯到 Brian Kernighan 在 1974 年的內部技術手冊 《Programming in C: A Tutorial》，
他在該手冊中用 B 語言（C 語言的前身）展示了類似的範例程式碼：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-b" data-lang="b">&lt;span class="line">&lt;span class="cl">&lt;span class="c">main() {
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c"> printf(&amp;#34;hello&lt;/span>&lt;span class="nt">,&lt;/span>&lt;span class="c"> world&amp;#34;);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">}
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="hugo-功能測試">Hugo 功能測試
&lt;/h2>&lt;h3 id="一般標記">一般標記
&lt;/h3>&lt;h4 id="斜體">&lt;em>斜體&lt;/em>
&lt;/h4>&lt;p>&lt;code>*斜體*&lt;/code>&lt;/p>
&lt;h4 id="粗體">&lt;strong>粗體&lt;/strong>
&lt;/h4>&lt;p>&lt;code>**粗體**&lt;/code>&lt;/p>
&lt;h4 id="刪除線">&lt;del>刪除線&lt;/del>
&lt;/h4>&lt;p>&lt;code>~~刪除線~~&lt;/code>&lt;/p>
&lt;h4 id="標記">&lt;mark>標記&lt;/mark>
&lt;/h4>&lt;p>&lt;code>==標記==&lt;/code>&lt;/p>
&lt;h4 id="底線">&lt;ins>底線&lt;/ins>
&lt;/h4>&lt;p>&lt;code>++底線++&lt;/code>&lt;/p>
&lt;h4 id="上標">上&lt;sup>標&lt;/sup>
&lt;/h4>&lt;p>&lt;code>上^標^&lt;/code>&lt;/p>
&lt;h4 id="下標">下&lt;sub>標&lt;/sub>
&lt;/h4>&lt;p>&lt;code>下~標~&lt;/code>&lt;/p>
&lt;h3 id="程式碼">程式碼
&lt;/h3>&lt;h4 id="一般顯示">一般顯示
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#define hugo
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="程式碼標記">程式碼標記
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line hl">&lt;span class="ln">3&lt;/span>&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">&lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line hl">&lt;span class="ln">6&lt;/span>&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line hl">&lt;span class="ln">7&lt;/span>&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Value of i:&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line hl">&lt;span class="ln">8&lt;/span>&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">9&lt;/span>&lt;span class="cl">&lt;span class="p">}&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h3 id="latex-math">Latex Math
&lt;/h3>\[
\begin{aligned}
KL(\hat{y} || y) &amp;= \sum_{c=1}^{M}\hat{y}_c \log{\frac{\hat{y}_c}{y_c}} \\
JS(\hat{y} || y) &amp;= \frac{1}{2}(KL(y||\frac{y+\hat{y}}{2}) + KL(\hat{y}||\frac{y+\hat{y}}{2}))
\end{aligned}
\]&lt;p>This is an inline \(a^*=x-b^*\) equation.&lt;/p>
&lt;hr>
&lt;h4>參考資料&lt;/h4>
&lt;ul>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program" target="_blank" rel="noopener"
>wikipedia - &amp;ldquo;Hello, World!&amp;rdquo; program&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>